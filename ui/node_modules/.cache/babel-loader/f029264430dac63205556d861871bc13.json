{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst ArrayType = require('./array');\n\nconst CastError = require('../error/cast');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst SchemaDocumentArrayOptions = require('../options/SchemaDocumentArrayOptions');\n\nconst SchemaType = require('../schematype');\n\nconst discriminator = require('../helpers/model/discriminator');\n\nconst get = require('../helpers/get');\n\nconst handleIdOption = require('../helpers/schema/handleIdOption');\n\nconst util = require('util');\n\nconst utils = require('../utils');\n\nconst getConstructor = require('../helpers/discriminator/getConstructor');\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\n\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\n\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArrayPath(key, schema, options, schemaOptions) {\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n\n  EmbeddedDocument.prototype.$basePath = key;\n  ArrayType.call(this, key, EmbeddedDocument, options);\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n  EmbeddedDocument.base = schema.base;\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function () {\n      let arr = fn.call(this);\n\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      } // Leave it up to `cast()` to convert this to a documentarray\n\n\n      return arr;\n    });\n  }\n\n  const parentSchemaType = this;\n  this.$embeddedSchemaType = new SchemaType(key + '.$', {\n    required: get(this, 'schemaOptions.required', false)\n  });\n\n  this.$embeddedSchemaType.cast = function (value, doc, init) {\n    return parentSchemaType.cast(value, doc, init)[0];\n  };\n\n  this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nDocumentArrayPath.schemaName = 'DocumentArray';\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nDocumentArrayPath.options = {\n  castNonArrays: true\n};\n/*!\n * Inherits from ArrayType.\n */\n\nDocumentArrayPath.prototype = Object.create(ArrayType.prototype);\nDocumentArrayPath.prototype.constructor = DocumentArrayPath;\nDocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/ArraySubdocument')); // compile an embedded document for this schema\n\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    this.$session(this.ownerDocument().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter(); // apply methods\n\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  } // apply statics\n\n\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n  return EmbeddedDocument;\n}\n/**\n * Adds a discriminator to this document array.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators /docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\n\nDocumentArrayPath.prototype.discriminator = function (name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = get(options, 'clone', true);\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {// Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n  return this.casterConstructor.discriminators[name];\n};\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\n\nDocumentArrayPath.prototype.doValidate = function (array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));\n\n  const _this = this;\n\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n\n    if (options && options.updateValidator) {\n      return fn();\n    }\n\n    if (!array.isMongooseDocumentArray) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    } // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      } // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n\n\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\n\nDocumentArrayPath.prototype.doValidateSync = function (array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  } // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n\n    if (!doc) {\n      continue;\n    } // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n\n\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n/*!\n * ignore\n */\n\n\nDocumentArrayPath.prototype.getDefault = function (scope) {\n  let ret = typeof this.defaultValue === 'function' ? this.defaultValue.call(scope) : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  } // lazy load\n\n\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n\n    const _subdoc = new Constructor({}, ret, undefined, undefined, i);\n\n    _subdoc.$init(ret[i]);\n\n    _subdoc.isNew = true; // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\n\nDocumentArrayPath.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray')); // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n  const _opts = {\n    transform: false,\n    virtuals: false\n  };\n  options = options || {};\n\n  if (!Array.isArray(value)) {\n    if (!init && !DocumentArrayPath.options.castNonArrays) {\n      throw new CastError('DocumentArray', util.inspect(value), this.path, null, this);\n    } // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n\n\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  if (!(value && value.isMongooseDocumentArray) && !options.skipDocumentArrayCast) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = this.path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = value.isMongooseDocumentArrayProxy ? value.__array : value;\n  const len = rawArray.length;\n  const initDocumentOptions = {\n    skipId: true,\n    willInit: true\n  };\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, value[i]); // Check if the document has a different schema (re gh-3701)\n\n    if (rawArray[i].$__ && (!(rawArray[i] instanceof Constructor) || rawArray[i][documentArrayParent] !== doc)) {\n      rawArray[i] = rawArray[i].toObject({\n        transform: false,\n        // Special case: if different model, but same schema, apply virtuals\n        // re: gh-7898\n        virtuals: rawArray[i].schema === Constructor.schema\n      });\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]); // if set() is hooked it will have no return value\n          // see gh-746\n\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined, undefined, i); // if set() is hooked it will have no return value\n            // see gh-746\n\n            rawArray[i] = subdoc;\n          } catch (error) {\n            const valueInErrorMessage = util.inspect(rawArray[i]);\n            throw new CastError('embedded', valueInErrorMessage, value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n/*!\n * ignore\n */\n\n\nDocumentArrayPath.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n\n  schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);\n  return schematype;\n};\n/*!\n * ignore\n */\n\n\nDocumentArrayPath.prototype.applyGetters = function (value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n\n      if (sub === '$') {\n        continue;\n      }\n\n      if (sub.startsWith('$.')) {\n        sub = sub.substr(2);\n      }\n\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * ####Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\n\nDocumentArrayPath.defaultOptions = {};\nDocumentArrayPath.set = SchemaType.set;\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArrayPath;","map":{"version":3,"sources":["/home/gregorian/calendar-ui/node_modules/mongoose/lib/schema/documentarray.js"],"names":["ArrayType","require","CastError","EventEmitter","SchemaDocumentArrayOptions","SchemaType","discriminator","get","handleIdOption","util","utils","getConstructor","arrayAtomicsSymbol","arrayPathSymbol","documentArrayParent","MongooseDocumentArray","Subdocument","DocumentArrayPath","key","schema","options","schemaOptions","_id","EmbeddedDocument","_createConstructor","prototype","$basePath","call","$isMongooseDocumentArray","Constructor","base","fn","defaultValue","default","arr","Array","isArray","parentSchemaType","$embeddedSchemaType","required","cast","value","doc","init","$isMongooseDocumentArrayElement","caster","schemaName","castNonArrays","Object","create","constructor","OptionsConstructor","baseClass","apply","arguments","$session","ownerDocument","_preCompile","proto","$__setSchema","$isArraySubdocument","events","i","methods","statics","name","getFunctionName","tiedValue","isPOJO","clone","instanceOfSchema","casterConstructor","baseCasterConstructor","defineProperty","error","discriminators","doValidate","array","scope","_this","cb","err","count","length","updateValidator","isMongooseDocumentArray","path","callback","len","undefined","validateModifiedOnly","$isModified","$__validate","doValidateSync","schemaTypeError","resultError","subdocValidateError","validateSync","getDefault","ret","_subdoc","$init","isNew","assign","$__","activePaths","prev","selected","subdoc","_opts","transform","virtuals","inspect","markModified","skipDocumentArrayCast","arrayPathIndex","rawArray","isMongooseDocumentArrayProxy","__array","initDocumentOptions","skipId","willInit","toObject","__index","$setIndex","scopePaths","id","deepEqual","set","valueInErrorMessage","schematype","validators","slice","requiredValidator","applyGetters","fields","keys","hasKeys","sub","startsWith","substring","substr","defaultOptions","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayType = require('./array');\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaDocumentArrayOptions =\n  require('../options/SchemaDocumentArrayOptions');\nconst SchemaType = require('../schematype');\nconst discriminator = require('../helpers/model/discriminator');\nconst get = require('../helpers/get');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst util = require('util');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArrayPath(key, schema, options, schemaOptions) {\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const parentSchemaType = this;\n  this.$embeddedSchemaType = new SchemaType(key + '.$', {\n    required: get(this, 'schemaOptions.required', false)\n  });\n  this.$embeddedSchemaType.cast = function(value, doc, init) {\n    return parentSchemaType.cast(value, doc, init)[0];\n  };\n  this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDocumentArrayPath.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nDocumentArrayPath.options = { castNonArrays: true };\n\n/*!\n * Inherits from ArrayType.\n */\nDocumentArrayPath.prototype = Object.create(ArrayType.prototype);\nDocumentArrayPath.prototype.constructor = DocumentArrayPath;\nDocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/ArraySubdocument'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n\n    this.$session(this.ownerDocument().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators /docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nDocumentArrayPath.prototype.discriminator = function(name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = get(options, 'clone', true);\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!array.isMongooseDocumentArray) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidateSync = function(array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.getDefault = function(scope) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nDocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n  const _opts = { transform: false, virtuals: false };\n  options = options || {};\n\n  if (!Array.isArray(value)) {\n    if (!init && !DocumentArrayPath.options.castNonArrays) {\n      throw new CastError('DocumentArray', util.inspect(value), this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  if (!(value && value.isMongooseDocumentArray) &&\n      !options.skipDocumentArrayCast) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = this.path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = value.isMongooseDocumentArrayProxy ? value.__array : value;\n\n  const len = rawArray.length;\n  const initDocumentOptions = { skipId: true, willInit: true };\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, value[i]);\n\n    // Check if the document has a different schema (re gh-3701)\n    if ((rawArray[i].$__) &&\n        (!(rawArray[i] instanceof Constructor) || rawArray[i][documentArrayParent] !== doc)) {\n      rawArray[i] = rawArray[i].toObject({\n        transform: false,\n        // Special case: if different model, but same schema, apply virtuals\n        // re: gh-7898\n        virtuals: rawArray[i].schema === Constructor.schema\n      });\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            const valueInErrorMessage = util.inspect(rawArray[i]);\n            throw new CastError('embedded', valueInErrorMessage,\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.applyGetters = function(value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substr(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * ####Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nDocumentArrayPath.defaultOptions = {};\n\nDocumentArrayPath.set = SchemaType.set;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArrayPath;\n"]},"metadata":{},"sourceType":"script"}