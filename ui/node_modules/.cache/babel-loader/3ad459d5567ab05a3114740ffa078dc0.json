{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection = require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\n\nconst get = require('./helpers/get');\n\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\n\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\n\nconst clone = require('./helpers/clone');\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []); // lean options should trickle through all queries\n\n  if (options.lean != null) {\n    pop.filter(p => get(p, 'options.lean') == null).forEach(makeLean(options.lean));\n  }\n\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n  return pop;\n};\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []); // lean options should trickle through all queries\n\n  if (options.lean != null) {\n    pop.filter(p => get(p, 'options.lean') == null).forEach(makeLean(options.lean));\n  }\n\n  const session = get(query, 'options.session', null);\n\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n  return pop;\n};\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\n\n\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;\n  const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;\n  const value = doc[key];\n\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  if (typeof options === 'undefined') {\n    options = {};\n    options.defaults = true;\n  }\n\n  return new model(undefined, fields, {\n    skipId: true,\n    isNew: false,\n    willInit: true,\n    defaults: options.defaults\n  });\n};\n/*!\n * ignore\n */\n\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let keyIndex;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    keyIndex = keys.length;\n\n    while (keyIndex--) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n\n      const field = fields[keys[keyIndex]]; // Skip `$meta` and `$slice`\n\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n\n      exclude = !field;\n      break;\n    }\n  } // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n  analyzeSchema(schema);\n\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n\n      break;\n\n    case false:\n      if (schema && schema.paths['_id'] && schema.paths['_id'].options && schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n\n      break;\n\n    case undefined:\n      if (fields == null) {\n        break;\n      } // Any leftover plus paths must in the schema, so delete them (gh-7017)\n\n\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      } // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n\n\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = ''); // avoid recursion\n\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n\n    stack.push(schema);\n    const addedPaths = [];\n    schema.eachPath(function (path, type) {\n      if (prefix) path = prefix + '.' + path;\n      let addedPath = analyzePath(path, type); // arrays\n\n      if (addedPath == null && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      } // nested schemas\n\n\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path); // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n\n\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n\n    if (typeof type.selected !== 'boolean') return;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath]; // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    } // check for parent exclusions\n\n\n    const pieces = path.split('.');\n    let cur = '';\n\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    } // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n\n\n    if (!exclude && get(type, 'options.$skipDiscriminatorCheck', false)) {\n      let cur = '';\n\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\n\nfunction makeLean(val) {\n  return function (option) {\n    option.options || (option.options = {});\n\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}\n/*!\n * Handle the `WriteOpResult` from the server\n */\n\n\nexports.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {\n  return function _handleDeleteWriteOpResult(error, res) {\n    if (error) {\n      return callback(error);\n    }\n\n    const mongooseResult = Object.assign({}, res.result);\n\n    if (get(res, 'result.n', null) != null) {\n      mongooseResult.deletedCount = res.result.n;\n    }\n\n    if (res.deletedCount != null) {\n      mongooseResult.deletedCount = res.deletedCount;\n    }\n\n    return callback(null, mongooseResult);\n  };\n};","map":{"version":3,"sources":["/home/gregorian/calendar-ui/node_modules/mongoose/lib/queryhelpers.js"],"names":["checkEmbeddedDiscriminatorKeyProjection","require","get","getDiscriminatorByValue","isDefiningProjection","clone","exports","preparePopulationOptions","query","options","_populate","populate","pop","Object","keys","reduce","vals","key","concat","lean","filter","p","forEach","makeLean","opts","_localModel","model","preparePopulationOptionsMQ","_mongooseOptions","session","path","projection","_fieldsForExec","_queryProjection","createModel","doc","fields","userProvidedFields","hooks","execPreSync","discriminatorMapping","schema","isRoot","value","discriminators","discriminator","_fields","applyPaths","undefined","defaults","skipId","isNew","willInit","exclude","keyIndex","length","field","selected","excluded","stack","analyzeSchema","fieldName","paths","select","_id","startsWith","prefix","indexOf","push","addedPaths","eachPath","type","addedPath","analyzePath","$isMongooseArray","$isMongooseDocumentArray","caster","_addedPaths","plusPath","hasPlusPath","pieces","split","cur","i","val","option","Array","isArray","virtuals","assign","map","slice","handleDeleteWriteOpResult","callback","_handleDeleteWriteOpResult","error","res","mongooseResult","result","deletedCount","n"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection =\n  require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue =\n  require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\n\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.\n      filter(p => get(p, 'options.lean') == null).\n      forEach(makeLean(options.lean));\n  }\n\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.\n      filter(p => get(p, 'options.lean') == null).\n      forEach(makeLean(options.lean));\n  }\n\n  const session = get(query, 'options.session', null);\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n  if (typeof options === 'undefined') {\n    options = {};\n    options.defaults = true;\n  }\n  return new model(undefined, fields, {\n    skipId: true,\n    isNew: false,\n    willInit: true,\n    defaults: options.defaults\n  });\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let keyIndex;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    keyIndex = keys.length;\n\n    while (keyIndex--) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n\n    if (typeof type.selected !== 'boolean') return;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && get(type, 'options.$skipDiscriminatorCheck', false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.\n        filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).\n        map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}\n\n/*!\n * Handle the `WriteOpResult` from the server\n */\n\nexports.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {\n  return function _handleDeleteWriteOpResult(error, res) {\n    if (error) {\n      return callback(error);\n    }\n    const mongooseResult = Object.assign({}, res.result);\n    if (get(res, 'result.n', null) != null) {\n      mongooseResult.deletedCount = res.result.n;\n    }\n    if (res.deletedCount != null) {\n      mongooseResult.deletedCount = res.deletedCount;\n    }\n    return callback(null, mongooseResult);\n  };\n};\n"]},"metadata":{},"sourceType":"script"}