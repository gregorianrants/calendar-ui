{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst ObjectExpectedError = require('../error/objectExpected');\n\nconst SchemaSubdocumentOptions = require('../options/SchemaSubdocumentOptions');\n\nconst SchemaType = require('../schematype');\n\nconst $exists = require('./operators/exists');\n\nconst castToNumber = require('./operators/helpers').castToNumber;\n\nconst discriminator = require('../helpers/model/discriminator');\n\nconst geospatial = require('./operators/geospatial');\n\nconst get = require('../helpers/get');\n\nconst getConstructor = require('../helpers/discriminator/getConstructor');\n\nconst handleIdOption = require('../helpers/schema/handleIdOption');\n\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\n\nconst utils = require('../utils');\n\nlet Subdocument;\nmodule.exports = SubdocumentPath;\n/**\n * Single nested subdocument SchemaType constructor.\n *\n * @param {Schema} schema\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SubdocumentPath(schema, path, options) {\n  schema = handleIdOption(schema, options);\n  this.caster = _createConstructor(schema);\n  this.caster.path = path;\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n/*!\n * ignore\n */\n\n\nSubdocumentPath.prototype = Object.create(SchemaType.prototype);\nSubdocumentPath.prototype.constructor = SubdocumentPath;\nSubdocumentPath.prototype.OptionsConstructor = SchemaSubdocumentOptions;\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, baseClass) {\n  // lazy load\n  Subdocument || (Subdocument = require('../types/subdocument'));\n\n  const _embedded = function SingleNested(value, path, parent) {\n    const _this = this;\n\n    this.$__parent = parent;\n    Subdocument.apply(this, arguments);\n    this.$session(this.ownerDocument().$session());\n\n    if (parent) {\n      parent.$on('save', function () {\n        _this.emit('save', _this);\n\n        _this.constructor.emit('save', _this);\n      });\n      parent.$on('isNew', function (val) {\n        _this.isNew = val;\n\n        _this.emit('isNew', val);\n\n        _this.constructor.emit('isNew', val);\n      });\n    }\n  };\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  _embedded.prototype = Object.create(proto);\n\n  _embedded.prototype.$__setSchema(schema);\n\n  _embedded.prototype.constructor = _embedded;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n\n  _embedded.prototype.toBSON = function () {\n    return this.toObject(internalToObjectOptions);\n  }; // apply methods\n\n\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  } // apply statics\n\n\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n\n  return _embedded;\n}\n/*!\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\n\nSubdocumentPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {\n  return {\n    $geometry: this.castForQuery(val.$geometry)\n  };\n};\n/*!\n * ignore\n */\n\n\nSubdocumentPath.prototype.$conditionalHandlers.$near = SubdocumentPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\nSubdocumentPath.prototype.$conditionalHandlers.$within = SubdocumentPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\nSubdocumentPath.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;\nSubdocumentPath.prototype.$conditionalHandlers.$minDistance = castToNumber;\nSubdocumentPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;\nSubdocumentPath.prototype.$conditionalHandlers.$exists = $exists;\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nSubdocumentPath.prototype.cast = function (val, doc, init, priorVal, options) {\n  if (val && val.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n\n  const Constructor = getConstructor(this.caster, val);\n  let subdoc; // Only pull relevant selected paths and pull out the base path\n\n  const parentSelected = get(doc, '$__.selected', {});\n  const path = this.path;\n  const selected = Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj[key.substr(path.length + 1)] = parentSelected[key];\n    }\n\n    return obj;\n  }, {});\n  options = Object.assign({}, options, {\n    priorDoc: priorVal\n  });\n\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc);\n    subdoc.$init(val);\n  } else {\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc, undefined, options);\n    }\n\n    return new Constructor(val, selected, doc, undefined, options);\n  }\n\n  return subdoc;\n};\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\n\nSubdocumentPath.prototype.castForQuery = function ($conditional, val, options) {\n  let handler;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n\n    return handler.call(this, val);\n  }\n\n  val = $conditional;\n\n  if (val == null) {\n    return val;\n  }\n\n  if (this.options.runSetters) {\n    val = this._applySetters(val);\n  }\n\n  const Constructor = getConstructor(this.caster, val);\n  const overrideStrict = options != null && options.strict != null ? options.strict : void 0;\n\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n\n    throw error;\n  }\n\n  return val;\n};\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\n\nSubdocumentPath.prototype.doValidate = function (value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (options && options.skipSchemaValidators) {\n    if (!(value instanceof Constructor)) {\n      value = new Constructor(value, null, scope);\n    }\n\n    return value.validate(fn);\n  }\n\n  SchemaType.prototype.doValidate.call(this, value, function (error) {\n    if (error) {\n      return fn(error);\n    }\n\n    if (!value) {\n      return fn(null);\n    }\n\n    value.validate(fn);\n  }, scope, options);\n};\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\n\nSubdocumentPath.prototype.doValidateSync = function (value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n\n  if (!value) {\n    return;\n  }\n\n  return value.validateSync();\n};\n/**\n * Adds a discriminator to this single nested subdocument.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shape: shapeSchema });\n *\n *     const singleNestedPath = parentSchema.path('shape');\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @see discriminators /docs/discriminators.html\n * @api public\n */\n\n\nSubdocumentPath.prototype.discriminator = function (name, schema, options) {\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = get(options, 'clone', true);\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.caster, name, schema, value);\n  this.caster.discriminators[name] = _createConstructor(schema, this.caster);\n  return this.caster.discriminators[name];\n};\n/**\n * Sets a default option for all SubdocumentPath instances.\n *\n * ####Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Embedded.set('required', true);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\n\nSubdocumentPath.defaultOptions = {};\nSubdocumentPath.set = SchemaType.set;\n/*!\n * ignore\n */\n\nSubdocumentPath.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.schema, this.path, options);\n  schematype.validators = this.validators.slice();\n\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n\n  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);\n  return schematype;\n};","map":{"version":3,"sources":["/home/gregorian/calendar-ui/node_modules/mongoose/lib/schema/SubdocumentPath.js"],"names":["CastError","require","EventEmitter","ObjectExpectedError","SchemaSubdocumentOptions","SchemaType","$exists","castToNumber","discriminator","geospatial","get","getConstructor","handleIdOption","internalToObjectOptions","utils","Subdocument","module","exports","SubdocumentPath","schema","path","options","caster","_createConstructor","prototype","$basePath","$isSingleNested","call","Object","create","constructor","OptionsConstructor","baseClass","_embedded","SingleNested","value","parent","_this","$__parent","apply","arguments","$session","ownerDocument","$on","emit","val","isNew","_preCompile","proto","$__setSchema","events","toBSON","toObject","i","methods","statics","$conditionalHandlers","$geoWithin","handle$geoWithin","$geometry","castForQuery","$near","$nearSphere","cast$near","$within","cast$within","$geoIntersects","cast$geoIntersects","$minDistance","$maxDistance","cast","doc","init","priorVal","Array","isArray","Constructor","subdoc","parentSelected","selected","keys","reduce","obj","key","startsWith","substr","length","assign","priorDoc","$init","undefined","$conditional","handler","Error","runSetters","_applySetters","overrideStrict","strict","error","doValidate","fn","scope","skipSchemaValidators","validate","doValidateSync","schemaTypeError","validateSync","name","isPOJO","clone","instanceOfSchema","discriminators","defaultOptions","set","schematype","validators","slice","requiredValidator"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst ObjectExpectedError = require('../error/objectExpected');\nconst SchemaSubdocumentOptions = require('../options/SchemaSubdocumentOptions');\nconst SchemaType = require('../schematype');\nconst $exists = require('./operators/exists');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst discriminator = require('../helpers/model/discriminator');\nconst geospatial = require('./operators/geospatial');\nconst get = require('../helpers/get');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\nconst utils = require('../utils');\n\nlet Subdocument;\n\nmodule.exports = SubdocumentPath;\n\n/**\n * Single nested subdocument SchemaType constructor.\n *\n * @param {Schema} schema\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SubdocumentPath(schema, path, options) {\n  schema = handleIdOption(schema, options);\n\n  this.caster = _createConstructor(schema);\n  this.caster.path = path;\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\n/*!\n * ignore\n */\n\nSubdocumentPath.prototype = Object.create(SchemaType.prototype);\nSubdocumentPath.prototype.constructor = SubdocumentPath;\nSubdocumentPath.prototype.OptionsConstructor = SchemaSubdocumentOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, baseClass) {\n  // lazy load\n  Subdocument || (Subdocument = require('../types/subdocument'));\n\n  const _embedded = function SingleNested(value, path, parent) {\n    const _this = this;\n\n    this.$__parent = parent;\n    Subdocument.apply(this, arguments);\n\n    this.$session(this.ownerDocument().$session());\n\n    if (parent) {\n      parent.$on('save', function() {\n        _this.emit('save', _this);\n        _this.constructor.emit('save', _this);\n      });\n\n      parent.$on('isNew', function(val) {\n        _this.isNew = val;\n        _this.emit('isNew', val);\n        _this.constructor.emit('isNew', val);\n      });\n    }\n  };\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  _embedded.prototype = Object.create(proto);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n  _embedded.prototype.toBSON = function() {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n\n  return _embedded;\n}\n\n/*!\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\nSubdocumentPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {\n  return { $geometry: this.castForQuery(val.$geometry) };\n};\n\n/*!\n * ignore\n */\n\nSubdocumentPath.prototype.$conditionalHandlers.$near =\nSubdocumentPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\n\nSubdocumentPath.prototype.$conditionalHandlers.$within =\nSubdocumentPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\n\nSubdocumentPath.prototype.$conditionalHandlers.$geoIntersects =\n  geospatial.cast$geoIntersects;\n\nSubdocumentPath.prototype.$conditionalHandlers.$minDistance = castToNumber;\nSubdocumentPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;\n\nSubdocumentPath.prototype.$conditionalHandlers.$exists = $exists;\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nSubdocumentPath.prototype.cast = function(val, doc, init, priorVal, options) {\n  if (val && val.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n\n  const Constructor = getConstructor(this.caster, val);\n\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = get(doc, '$__.selected', {});\n  const path = this.path;\n  const selected = Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj[key.substr(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, {});\n  options = Object.assign({}, options, { priorDoc: priorVal });\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc);\n    subdoc.$init(val);\n  } else {\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc, undefined, options);\n    }\n\n    return new Constructor(val, selected, doc, undefined, options);\n  }\n\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nSubdocumentPath.prototype.castForQuery = function($conditional, val, options) {\n  let handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  if (val == null) {\n    return val;\n  }\n\n  if (this.options.runSetters) {\n    val = this._applySetters(val);\n  }\n\n  const Constructor = getConstructor(this.caster, val);\n  const overrideStrict = options != null && options.strict != null ?\n    options.strict :\n    void 0;\n\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\nSubdocumentPath.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (options && options.skipSchemaValidators) {\n    if (!(value instanceof Constructor)) {\n      value = new Constructor(value, null, scope);\n    }\n    return value.validate(fn);\n  }\n\n  SchemaType.prototype.doValidate.call(this, value, function(error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n\n    value.validate(fn);\n  }, scope, options);\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nSubdocumentPath.prototype.doValidateSync = function(value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\n * Adds a discriminator to this single nested subdocument.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shape: shapeSchema });\n *\n *     const singleNestedPath = parentSchema.path('shape');\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @see discriminators /docs/discriminators.html\n * @api public\n */\n\nSubdocumentPath.prototype.discriminator = function(name, schema, options) {\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = get(options, 'clone', true);\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.caster, name, schema, value);\n\n  this.caster.discriminators[name] = _createConstructor(schema, this.caster);\n\n  return this.caster.discriminators[name];\n};\n\n/**\n * Sets a default option for all SubdocumentPath instances.\n *\n * ####Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Embedded.set('required', true);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSubdocumentPath.defaultOptions = {};\n\nSubdocumentPath.set = SchemaType.set;\n\n/*!\n * ignore\n */\n\nSubdocumentPath.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.schema, this.path, options);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);\n  return schematype;\n};\n"]},"metadata":{},"sourceType":"script"}