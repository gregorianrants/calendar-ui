{"ast":null,"code":"function idGenerator() {\n  let id = 0;\n  return () => id++; //TODO might want to look into whether this i cuasing a non unique id anywhere\n  //i think all event ids are coming from db now but worth a check at some point.\n}\n\nlet id = idGenerator();\nexport function timePeriod(start, end) {\n  return {\n    start: start,\n    end: end,\n    id: id()\n  };\n}\n/*let events = [\n    new TimePeriod(10, 13.5),\n    new TimePeriod(10.5, 11.5),\n    new TimePeriod(13, 14),\n    new TimePeriod(16, 17),\n    new TimePeriod(15.5, 16.5),\n    new TimePeriod(21,23)\n]*/\n\n/*let groups = events.map(event => [event])*/\n\nfunction getStart(set) {\n  return set.map(event => event.start).reduce((a, b) => new Date(Math.min(a, b)));\n}\n\nfunction getEnd(set) {\n  return set.map(event => event.end).reduce((a, b) => new Date(Math.max(a, b)));\n}\n\nfunction asPeriod(set) {\n  return timePeriod(getStart(set), getEnd(set));\n}\n\nfunction overlaps(period1, period2) {\n  /*return period1.start <= period2.end && period2.start <= period1.end*/\n  return period1.start < period2.end && period2.start < period1.end;\n}\n\nfunction negate(f) {\n  return (...args) => {\n    return !f(...args);\n  };\n}\n/*\nfunction sortAscending(arr) {\n    return [...arr].sort((a, b) => a - b)\n}\n*/\n\n\nfunction sortAscending(arr) {\n  return [...arr].sort((a, b) => a.start - b.start);\n}\n\nfunction difference(arrayA, arrayB) {\n  let ids = arrayA.map(event => event._id);\n  return arrayB.filter(event => !ids.includes(event._id));\n}\n\nfunction extractSet(periods, condition) {\n  return sortAscending(periods).reduce((set, period) => set.length === 0 || condition(period, asPeriod(set)) ? [...set, period] : set, []);\n}\n\nfunction extractSetWith(condition) {\n  return periods => {\n    return extractSet(periods, condition);\n  };\n}\n\nfunction buildSets(periods, extractionF, sets = []) {\n  if (periods.length === 0) return sets;\n  let set = extractionF(periods);\n  return buildSets(difference(set, periods), extractionF, [...sets, set]);\n}\n\nfunction buildSetsWith(extractionF) {\n  return periods => {\n    return buildSets(periods, extractionF, []);\n  };\n}\n\nexport default function groupEvents(events) {\n  let overlappingSets = buildSetsWith(extractSetWith(overlaps))(events);\n  let withColumns = overlappingSets.map(set => {\n    return buildSetsWith(extractSetWith(negate(overlaps)))(set);\n  });\n  return withColumns;\n} //console.log(overlappingSets)\n\n/*\nconsole.log(JSON.stringify(withColumns,null, 2))*/","map":{"version":3,"sources":["/home/gregorian/calendar-ui/ui/src/eventGeometry/groupEvents.js"],"names":["idGenerator","id","timePeriod","start","end","getStart","set","map","event","reduce","a","b","Date","Math","min","getEnd","max","asPeriod","overlaps","period1","period2","negate","f","args","sortAscending","arr","sort","difference","arrayA","arrayB","ids","_id","filter","includes","extractSet","periods","condition","period","length","extractSetWith","buildSets","extractionF","sets","buildSetsWith","groupEvents","events","overlappingSets","withColumns"],"mappings":"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","sourcesContent":["\n\nfunction idGenerator() {\n    let id = 0\n    return () => id++  //TODO might want to look into whether this i cuasing a non unique id anywhere\n    //i think all event ids are coming from db now but worth a check at some point.\n}\n\nlet id = idGenerator()\n\nexport function timePeriod(start, end) {\n    return {\n        start: start,\n        end: end,\n        id: id()}\n}\n\n/*let events = [\n    new TimePeriod(10, 13.5),\n    new TimePeriod(10.5, 11.5),\n    new TimePeriod(13, 14),\n    new TimePeriod(16, 17),\n    new TimePeriod(15.5, 16.5),\n    new TimePeriod(21,23)\n]*/\n\n\n\n/*let groups = events.map(event => [event])*/\n\nfunction getStart(set) {\n    return set.map(event => event.start).reduce((a, b) => new Date(Math.min(a, b)))\n}\n\nfunction getEnd(set) {\n    return set.map(event => event.end).reduce((a, b) => new Date(Math.max(a, b)))\n}\n\nfunction asPeriod(set) {\n    return timePeriod(getStart(set), getEnd(set))\n}\n\nfunction overlaps(period1, period2) {\n    /*return period1.start <= period2.end && period2.start <= period1.end*/\n    return period1.start < period2.end && period2.start < period1.end\n\n}\n\nfunction negate(f){\n    return (...args)=>{\n        return !f(...args)\n    }\n}\n\n\n/*\nfunction sortAscending(arr) {\n    return [...arr].sort((a, b) => a - b)\n}\n*/\n\nfunction sortAscending(arr) {\n    return [...arr].sort((a, b) => a.start - b.start)\n}\n\n\nfunction difference(arrayA, arrayB) {\n    let ids = arrayA.map(event => event._id)\n    return arrayB.filter(event => !ids.includes(event._id))\n}\n\n\nfunction extractSet(periods, condition) {\n    return (\n        sortAscending(periods)\n            .reduce(\n                (set, period) => set.length === 0 || condition(period, asPeriod(set)) ? [...set, period] : set\n                , [])\n    )\n}\n\nfunction extractSetWith(condition){\n    return (periods)=>{\n        return extractSet(periods,condition)\n    }\n}\n\nfunction buildSets(periods, extractionF, sets = []) {\n    if (periods.length === 0) return sets\n    let set = extractionF(periods)\n    return buildSets(\n        difference(set, periods),\n        extractionF,\n        [...sets, set])\n}\n\nfunction buildSetsWith(extractionF){\n    return (periods)=>{\n        return buildSets(periods,extractionF,[])\n    }\n}\n\n\n\nexport default function groupEvents(events){\n\n    let overlappingSets = buildSetsWith(extractSetWith(overlaps))(events)\n\n    let withColumns = overlappingSets.map(set=>{\n        return buildSetsWith(extractSetWith(negate(overlaps)))(set)\n    })\n    return withColumns\n}\n\n\n\n//console.log(overlappingSets)\n\n/*\nconsole.log(JSON.stringify(withColumns,null, 2))*/\n"]},"metadata":{},"sourceType":"module"}