{"ast":null,"code":"'use strict';\n\nconst symbols = require('../../schema/symbols');\n\nconst promiseOrCallback = require('../promiseOrCallback');\n/*!\n * ignore\n */\n\n\nmodule.exports = applyHooks;\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = ['deleteOne', 'save', 'validate', 'remove', 'updateOne', 'init'];\n/*!\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n  model.$appliedHooks = true;\n\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    let childModel = null;\n\n    if (type.$isSingleNested) {\n      childModel = type.caster;\n    } else if (type.$isMongooseDocumentArray) {\n      childModel = type.Constructor;\n    } else {\n      continue;\n    }\n\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n\n    applyHooks(childModel, type.schema, options);\n\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n\n      for (const key of keys) {\n        applyHooks(childModel.discriminators[key], childModel.discriminators[key].schema, options);\n      }\n    }\n  } // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n\n  const middleware = schema.s.hooks.filter(hook => {\n    if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n      return !!hook['document'];\n    }\n\n    if (hook.name === 'remove' || hook.name === 'init') {\n      return hook['document'] == null || !!hook['document'];\n    }\n\n    if (hook.query != null || hook.document != null) {\n      return hook.document !== false;\n    }\n\n    return true;\n  }).filter(hook => {\n    // If user has overwritten the method, don't apply built-in middleware\n    if (schema.methods[hook.name]) {\n      return !hook.fn[symbols.builtInMiddleware];\n    }\n\n    return true;\n  });\n  model._middleware = middleware;\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\n\n  for (const method of ['save', 'validate', 'remove', 'deleteOne']) {\n    const toWrap = method === 'validate' ? '$__originalValidate' : `$__${method}`;\n    const wrapped = middleware.createWrapper(method, objToDecorate[toWrap], null, kareemOptions);\n    objToDecorate[`$__${method}`] = wrapped;\n  }\n\n  objToDecorate.$__init = middleware.createWrapperSync('init', objToDecorate.$__init, null, kareemOptions); // Support hooks for custom methods\n\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n\n  for (const method of customMethods) {\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n\n    const originalMethod = objToDecorate[method];\n\n    objToDecorate[method] = function () {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = args.slice(-1).pop();\n      const argsWithoutCallback = typeof cb === 'function' ? args.slice(0, args.length - 1) : args;\n      return promiseOrCallback(cb, callback => {\n        return this[`$__${method}`].apply(this, argsWithoutCallback.concat([callback]));\n      }, model.events);\n    };\n\n    objToDecorate[`$__${method}`] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}","map":{"version":3,"sources":["/home/gregorian/calendar-ui/node_modules/mongoose/lib/helpers/model/applyHooks.js"],"names":["symbols","require","promiseOrCallback","module","exports","applyHooks","middlewareFunctions","model","schema","options","kareemOptions","useErrorHandlers","numCallbackParams","nullResultByDefault","contextParameter","objToDecorate","decorateDoc","prototype","$appliedHooks","key","Object","keys","paths","type","childModel","$isSingleNested","caster","$isMongooseDocumentArray","Constructor","discriminators","middleware","s","hooks","filter","hook","name","query","document","methods","fn","builtInMiddleware","_middleware","$__originalValidate","$__validate","method","toWrap","wrapped","createWrapper","$__init","createWrapperSync","customMethods","customMethodOptions","assign","checkForPromise","hasHooks","originalMethod","args","Array","slice","call","arguments","cb","pop","argsWithoutCallback","length","callback","apply","concat","events"],"mappings":"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","sourcesContent":["'use strict';\n\nconst symbols = require('../../schema/symbols');\nconst promiseOrCallback = require('../promiseOrCallback');\n\n/*!\n * ignore\n */\n\nmodule.exports = applyHooks;\n\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = [\n  'deleteOne',\n  'save',\n  'validate',\n  'remove',\n  'updateOne',\n  'init'\n];\n\n/*!\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n\n  model.$appliedHooks = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    let childModel = null;\n    if (type.$isSingleNested) {\n      childModel = type.caster;\n    } else if (type.$isMongooseDocumentArray) {\n      childModel = type.Constructor;\n    } else {\n      continue;\n    }\n\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n\n    applyHooks(childModel, type.schema, options);\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n      for (const key of keys) {\n        applyHooks(childModel.discriminators[key],\n          childModel.discriminators[key].schema, options);\n      }\n    }\n  }\n\n  // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n  const middleware = schema.s.hooks.\n    filter(hook => {\n      if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n        return !!hook['document'];\n      }\n      if (hook.name === 'remove' || hook.name === 'init') {\n        return hook['document'] == null || !!hook['document'];\n      }\n      if (hook.query != null || hook.document != null) {\n        return hook.document !== false;\n      }\n      return true;\n    }).\n    filter(hook => {\n      // If user has overwritten the method, don't apply built-in middleware\n      if (schema.methods[hook.name]) {\n        return !hook.fn[symbols.builtInMiddleware];\n      }\n\n      return true;\n    });\n\n  model._middleware = middleware;\n\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\n\n  for (const method of ['save', 'validate', 'remove', 'deleteOne']) {\n    const toWrap = method === 'validate' ? '$__originalValidate' : `$__${method}`;\n    const wrapped = middleware.\n      createWrapper(method, objToDecorate[toWrap], null, kareemOptions);\n    objToDecorate[`$__${method}`] = wrapped;\n  }\n  objToDecorate.$__init = middleware.\n    createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\n\n  // Support hooks for custom methods\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n  for (const method of customMethods) {\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n    const originalMethod = objToDecorate[method];\n    objToDecorate[method] = function() {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = args.slice(-1).pop();\n      const argsWithoutCallback = typeof cb === 'function' ?\n        args.slice(0, args.length - 1) : args;\n      return promiseOrCallback(cb, callback => {\n        return this[`$__${method}`].apply(this,\n          argsWithoutCallback.concat([callback]));\n      }, model.events);\n    };\n    objToDecorate[`$__${method}`] = middleware.\n      createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}"]},"metadata":{},"sourceType":"script"}