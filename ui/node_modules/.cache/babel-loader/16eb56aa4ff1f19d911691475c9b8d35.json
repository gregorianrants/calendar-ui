{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\n\nconst $type = require('./operators/type');\n\nconst MongooseError = require('../error/mongooseError');\n\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\n\nconst SchemaType = require('../schematype');\n\nconst CastError = SchemaType.CastError;\n\nconst Mixed = require('./mixed');\n\nconst arrayDepth = require('../helpers/arrayDepth');\n\nconst cast = require('../cast');\n\nconst get = require('../helpers/get');\n\nconst isOperator = require('../helpers/query/isOperator');\n\nconst util = require('util');\n\nconst utils = require('../utils');\n\nconst castToNumber = require('./operators/helpers').castToNumber;\n\nconst geospatial = require('./operators/geospatial');\n\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n  let typeKey = 'type';\n\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    } // support { type: 'String' }\n\n\n    const name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' && !caster.$isArraySubdocument && !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n  SchemaType.call(this, key, options, 'Array');\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function () {\n      let arr = [];\n\n      if (fn) {\n        arr = defaultArr.call(this);\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      } // Leave it up to `cast()` to convert the array\n\n\n      return arr;\n    };\n\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nSchemaArray.schemaName = 'Array';\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = {\n  castNonArrays: true\n};\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n/**\n * Sets a default option for all Array instances.\n *\n * ####Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @api public\n */\n\nSchemaArray.set = SchemaType.set;\n/*!\n * Inherits from SchemaType.\n */\n\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  } // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n\n\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ? this.constructor.checkRequired() : SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaArray} this\n */\n\n\nSchemaArray.prototype.enum = function () {\n  let arr = this;\n\n  while (true) {\n    const instance = get(arr, 'caster.instance');\n\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' + ', not ' + instance);\n    }\n\n    break;\n  }\n\n  let enumArray = arguments;\n\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n\n  if (Array.isArray(ret)) {\n    const rawValue = ret.isMongooseArrayProxy ? ret.__array : ret;\n    const len = rawValue.length;\n\n    for (let i = 0; i < len; ++i) {\n      rawValue[i] = this.caster.applyGetters(rawValue[i], scope);\n    }\n  }\n\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function (value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n\n    while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    } // No need to wrap empty arrays\n\n\n    if (value != null && value.length > 0) {\n      const valueDepth = arrayDepth(value);\n\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\n\nSchemaArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n      const arrayPath = this.path;\n\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      } // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n\n\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ? this.path.substr(0, this.path.lastIndexOf('.')) : null;\n\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n    let rawValue = value.isMongooseArrayProxy ? value.__array : value;\n    value = MongooseArray(rawValue, options.path || this._arrayPath || this.path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n\n        for (i = 0; i < len; i++) {\n          const opts = {}; // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n/*!\n * ignore\n */\n\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n    const caster = this.caster;\n\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {}; // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n/*!\n * Ignore\n */\n\nSchemaArray.prototype.discriminator = function (name, schema) {\n  let arr = this;\n\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' + 'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n\n  return arr.discriminator(name, schema);\n};\n/*!\n * ignore\n */\n\n\nSchemaArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n\n  return schematype;\n};\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\n\nSchemaArray.prototype.castForQuery = function ($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function (v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function (v) {\n    if (utils.isObject(v)) {\n      const o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n\n    return v;\n  }, this);\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value);\n    }\n  } // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n\n\n  const discriminatorKey = get(this, 'casterConstructor.schema.options.discriminatorKey');\n  const discriminators = get(this, 'casterConstructor.schema.discriminators', {});\n\n  if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema, obj));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$exists = $exists;\nhandle.$type = $type;\nhandle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$regex = SchemaArray.prototype.castForQuery; // `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\n\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"sources":["/home/gregorian/calendar-ui/node_modules/mongoose/lib/schema/array.js"],"names":["$exists","require","$type","MongooseError","SchemaArrayOptions","SchemaType","CastError","Mixed","arrayDepth","cast","get","isOperator","util","utils","castToNumber","geospatial","getDiscriminatorByValue","MongooseArray","EmbeddedDoc","isNestedArraySymbol","Symbol","emptyOpts","Object","freeze","SchemaArray","key","options","schemaOptions","Embedded","typeKey","castOptions","isPOJO","clone","ref","name","getFunctionName","Types","caster","hasOwnProperty","casterConstructor","$isArraySubdocument","$isSchemaMap","path","$embeddedSchemaType","$isMongooseArray","call","defaultArr","fn","defaultValue","defaultFn","arr","concat","$runBeforeSetters","default","schemaName","castNonArrays","defaultOptions","set","prototype","create","constructor","OptionsConstructor","_checkRequired","checkRequired","value","doc","_isRef","enum","instance","Error","enumArray","arguments","Array","isArray","isObject","object","vals","apply","applyGetters","scope","$__","$populated","ret","rawValue","isMongooseArrayProxy","__array","len","length","i","_applySetters","init","priorVal","depth","$isMongooseDocumentArray","valueDepth","min","max","containsNonArrayItem","prev","l","indexes","schema","indexedPaths","arrayPath","pathIndex","arrayGeojsonPath","endsWith","substr","lastIndexOf","_arrayPath","isMongooseArray","opts","arrayPathIndex","_arrayParentPath","applySetters","e","kind","inspect","markModified","_castForPopulate","$toObject","toObject","discriminator","assign","schematype","validators","slice","requiredValidator","undefined","castForQuery","$conditional","handler","val","$conditionalHandlers","Constructor","discriminators","discriminatorKey","constructorByValue","proto","method","setters","reverse","forEach","setter","map","v","$elemMatch","cast$all","o","cast$elemMatch","keys","numKeys","handle","$all","$options","String","$geoIntersects","cast$geoIntersects","$or","createLogicalQueryOperatorHandler","$and","$nor","op","logicalQueryOperatorHandler","TypeError","obj","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$lt","$lte","$ne","$regex","$nin","$in","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,oBAAD,CAAvB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,kBAAD,CAArB;;AACA,MAAME,aAAa,GAAGF,OAAO,CAAC,wBAAD,CAA7B;;AACA,MAAMG,kBAAkB,GAAGH,OAAO,CAAC,+BAAD,CAAlC;;AACA,MAAMI,UAAU,GAAGJ,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAMK,SAAS,GAAGD,UAAU,CAACC,SAA7B;;AACA,MAAMC,KAAK,GAAGN,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMO,UAAU,GAAGP,OAAO,CAAC,uBAAD,CAA1B;;AACA,MAAMQ,IAAI,GAAGR,OAAO,CAAC,SAAD,CAApB;;AACA,MAAMS,GAAG,GAAGT,OAAO,CAAC,gBAAD,CAAnB;;AACA,MAAMU,UAAU,GAAGV,OAAO,CAAC,6BAAD,CAA1B;;AACA,MAAMW,IAAI,GAAGX,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMY,KAAK,GAAGZ,OAAO,CAAC,UAAD,CAArB;;AACA,MAAMa,YAAY,GAAGb,OAAO,CAAC,qBAAD,CAAP,CAA+Ba,YAApD;;AACA,MAAMC,UAAU,GAAGd,OAAO,CAAC,wBAAD,CAA1B;;AACA,MAAMe,uBAAuB,GAAGf,OAAO,CAAC,kDAAD,CAAvC;;AAEA,IAAIgB,aAAJ;AACA,IAAIC,WAAJ;AAEA,MAAMC,mBAAmB,GAAGC,MAAM,CAAC,wBAAD,CAAlC;AACA,MAAMC,SAAS,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,WAAT,CAAqBC,GAArB,EAA0BhB,IAA1B,EAAgCiB,OAAhC,EAAyCC,aAAzC,EAAwD;AACtD;AACAT,EAAAA,WAAW,KAAKA,WAAW,GAAGjB,OAAO,CAAC,UAAD,CAAP,CAAoB2B,QAAvC,CAAX;AAEA,MAAIC,OAAO,GAAG,MAAd;;AACA,MAAIF,aAAa,IAAIA,aAAa,CAACE,OAAnC,EAA4C;AAC1CA,IAAAA,OAAO,GAAGF,aAAa,CAACE,OAAxB;AACD;;AACD,OAAKF,aAAL,GAAqBA,aAArB;;AAEA,MAAIlB,IAAJ,EAAU;AACR,QAAIqB,WAAW,GAAG,EAAlB;;AAEA,QAAIjB,KAAK,CAACkB,MAAN,CAAatB,IAAb,CAAJ,EAAwB;AACtB,UAAIA,IAAI,CAACoB,OAAD,CAAR,EAAmB;AACjB;AACAC,QAAAA,WAAW,GAAGjB,KAAK,CAACmB,KAAN,CAAYvB,IAAZ,CAAd,CAFiB,CAEgB;;AACjC,eAAOqB,WAAW,CAACD,OAAD,CAAlB;AACApB,QAAAA,IAAI,GAAGA,IAAI,CAACoB,OAAD,CAAX;AACD,OALD,MAKO;AACLpB,QAAAA,IAAI,GAAGF,KAAP;AACD;AACF;;AAED,QAAImB,OAAO,IAAI,IAAX,IAAmBA,OAAO,CAACO,GAAR,IAAe,IAAlC,IAA0CH,WAAW,CAACG,GAAZ,IAAmB,IAAjE,EAAuE;AACrEH,MAAAA,WAAW,CAACG,GAAZ,GAAkBP,OAAO,CAACO,GAA1B;AACD;;AAED,QAAIxB,IAAI,KAAKa,MAAb,EAAqB;AACnBb,MAAAA,IAAI,GAAGF,KAAP;AACD,KApBO,CAsBR;;;AACA,UAAM2B,IAAI,GAAG,OAAOzB,IAAP,KAAgB,QAAhB,GACTA,IADS,GAETI,KAAK,CAACsB,eAAN,CAAsB1B,IAAtB,CAFJ;;AAIA,UAAM2B,KAAK,GAAGnC,OAAO,CAAC,YAAD,CAArB;;AACA,UAAMoC,MAAM,GAAGD,KAAK,CAACE,cAAN,CAAqBJ,IAArB,IAA6BE,KAAK,CAACF,IAAD,CAAlC,GAA2CzB,IAA1D;AAEA,SAAK8B,iBAAL,GAAyBF,MAAzB;;AAEA,QAAI,KAAKE,iBAAL,YAAkCf,WAAtC,EAAmD;AACjD,WAAKe,iBAAL,CAAuBpB,mBAAvB,IAA8C,IAA9C;AACD;;AAED,QAAI,OAAOkB,MAAP,KAAkB,UAAlB,IACA,CAACA,MAAM,CAACG,mBADR,IAEA,CAACH,MAAM,CAACI,YAFZ,EAE0B;AACxB,YAAMC,IAAI,GAAG,KAAKL,MAAL,YAAuBnB,WAAvB,GAAqC,IAArC,GAA4CO,GAAzD;AACA,WAAKY,MAAL,GAAc,IAAIA,MAAJ,CAAWK,IAAX,EAAiBZ,WAAjB,CAAd;AACD,KALD,MAKO;AACL,WAAKO,MAAL,GAAcA,MAAd;;AACA,UAAI,EAAE,KAAKA,MAAL,YAAuBnB,WAAzB,CAAJ,EAA2C;AACzC,aAAKmB,MAAL,CAAYK,IAAZ,GAAmBjB,GAAnB;AACD;AACF;;AAED,SAAKkB,mBAAL,GAA2B,KAAKN,MAAhC;AACD;;AAED,OAAKO,gBAAL,GAAwB,IAAxB;AAEAvC,EAAAA,UAAU,CAACwC,IAAX,CAAgB,IAAhB,EAAsBpB,GAAtB,EAA2BC,OAA3B,EAAoC,OAApC;AAEA,MAAIoB,UAAJ;AACA,MAAIC,EAAJ;;AAEA,MAAI,KAAKC,YAAL,IAAqB,IAAzB,EAA+B;AAC7BF,IAAAA,UAAU,GAAG,KAAKE,YAAlB;AACAD,IAAAA,EAAE,GAAG,OAAOD,UAAP,KAAsB,UAA3B;AACD;;AAED,MAAI,EAAE,kBAAkB,IAApB,KAA6B,KAAKE,YAAL,KAAsB,KAAK,CAA5D,EAA+D;AAC7D,UAAMC,SAAS,GAAG,YAAW;AAC3B,UAAIC,GAAG,GAAG,EAAV;;AACA,UAAIH,EAAJ,EAAQ;AACNG,QAAAA,GAAG,GAAGJ,UAAU,CAACD,IAAX,CAAgB,IAAhB,CAAN;AACD,OAFD,MAEO,IAAIC,UAAU,IAAI,IAAlB,EAAwB;AAC7BI,QAAAA,GAAG,GAAGA,GAAG,CAACC,MAAJ,CAAWL,UAAX,CAAN;AACD,OAN0B,CAO3B;;;AACA,aAAOI,GAAP;AACD,KATD;;AAUAD,IAAAA,SAAS,CAACG,iBAAV,GAA8B,CAACL,EAA/B;AACA,SAAKM,OAAL,CAAaJ,SAAb;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;;;AACAzB,WAAW,CAAC8B,UAAZ,GAAyB,OAAzB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA9B,WAAW,CAACE,OAAZ,GAAsB;AAAE6B,EAAAA,aAAa,EAAE;AAAjB,CAAtB;AAEA;AACA;AACA;;AAEA/B,WAAW,CAACgC,cAAZ,GAA6B,EAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAhC,WAAW,CAACiC,GAAZ,GAAkBpD,UAAU,CAACoD,GAA7B;AAEA;AACA;AACA;;AACAjC,WAAW,CAACkC,SAAZ,GAAwBpC,MAAM,CAACqC,MAAP,CAActD,UAAU,CAACqD,SAAzB,CAAxB;AACAlC,WAAW,CAACkC,SAAZ,CAAsBE,WAAtB,GAAoCpC,WAApC;AACAA,WAAW,CAACkC,SAAZ,CAAsBG,kBAAtB,GAA2CzD,kBAA3C;AAEA;AACA;AACA;;AAEAoB,WAAW,CAACsC,cAAZ,GAA6BzD,UAAU,CAACqD,SAAX,CAAqBK,aAAlD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAvC,WAAW,CAACuC,aAAZ,GAA4B1D,UAAU,CAAC0D,aAAvC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAvC,WAAW,CAACkC,SAAZ,CAAsBK,aAAtB,GAAsC,SAASA,aAAT,CAAuBC,KAAvB,EAA8BC,GAA9B,EAAmC;AACvE,MAAI5D,UAAU,CAAC6D,MAAX,CAAkB,IAAlB,EAAwBF,KAAxB,EAA+BC,GAA/B,EAAoC,IAApC,CAAJ,EAA+C;AAC7C,WAAO,CAAC,CAACD,KAAT;AACD,GAHsE,CAKvE;AACA;;;AACA,QAAMF,cAAc,GAAG,OAAO,KAAKF,WAAL,CAAiBG,aAAxB,IAAyC,UAAzC,GACrB,KAAKH,WAAL,CAAiBG,aAAjB,EADqB,GAErBvC,WAAW,CAACuC,aAAZ,EAFF;;AAIA,SAAOD,cAAc,CAACE,KAAD,CAArB;AACD,CAZD;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAxC,WAAW,CAACkC,SAAZ,CAAsBS,IAAtB,GAA6B,YAAW;AACtC,MAAIjB,GAAG,GAAG,IAAV;;AACA,SAAO,IAAP,EAAa;AACX,UAAMkB,QAAQ,GAAG1D,GAAG,CAACwC,GAAD,EAAM,iBAAN,CAApB;;AACA,QAAIkB,QAAQ,KAAK,OAAjB,EAA0B;AACxBlB,MAAAA,GAAG,GAAGA,GAAG,CAACb,MAAV;AACA;AACD;;AACD,QAAI+B,QAAQ,KAAK,QAAb,IAAyBA,QAAQ,KAAK,QAA1C,EAAoD;AAClD,YAAM,IAAIC,KAAJ,CAAU,8DACd,QADc,GACHD,QADP,CAAN;AAED;;AACD;AACD;;AAED,MAAIE,SAAS,GAAGC,SAAhB;;AACA,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,SAAd,CAAD,IAA6B1D,KAAK,CAAC6D,QAAN,CAAeH,SAAf,CAAjC,EAA4D;AAC1DD,IAAAA,SAAS,GAAGzD,KAAK,CAAC8D,MAAN,CAAaC,IAAb,CAAkBN,SAAlB,CAAZ;AACD;;AAEDpB,EAAAA,GAAG,CAACb,MAAJ,CAAW8B,IAAX,CAAgBU,KAAhB,CAAsB3B,GAAG,CAACb,MAA1B,EAAkCiC,SAAlC;AACA,SAAO,IAAP;AACD,CAtBD;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA9C,WAAW,CAACkC,SAAZ,CAAsBoB,YAAtB,GAAqC,UAASd,KAAT,EAAgBe,KAAhB,EAAuB;AAC1D,MAAIA,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACC,GAAN,IAAa,IAA9B,IAAsCD,KAAK,CAACE,UAAN,CAAiB,KAAKvC,IAAtB,CAA1C,EAAuE;AACrE;AACA,WAAOsB,KAAP;AACD;;AAED,QAAMkB,GAAG,GAAG7E,UAAU,CAACqD,SAAX,CAAqBoB,YAArB,CAAkCjC,IAAlC,CAAuC,IAAvC,EAA6CmB,KAA7C,EAAoDe,KAApD,CAAZ;;AACA,MAAIP,KAAK,CAACC,OAAN,CAAcS,GAAd,CAAJ,EAAwB;AACtB,UAAMC,QAAQ,GAAGD,GAAG,CAACE,oBAAJ,GAA2BF,GAAG,CAACG,OAA/B,GAAyCH,GAA1D;AACA,UAAMI,GAAG,GAAGH,QAAQ,CAACI,MAArB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyB,EAAEE,CAA3B,EAA8B;AAC5BL,MAAAA,QAAQ,CAACK,CAAD,CAAR,GAAc,KAAKnD,MAAL,CAAYyC,YAAZ,CAAyBK,QAAQ,CAACK,CAAD,CAAjC,EAAsCT,KAAtC,CAAd;AACD;AACF;;AACD,SAAOG,GAAP;AACD,CAfD;;AAiBA1D,WAAW,CAACkC,SAAZ,CAAsB+B,aAAtB,GAAsC,UAASzB,KAAT,EAAgBe,KAAhB,EAAuBW,IAAvB,EAA6BC,QAA7B,EAAuC;AAC3E,MAAI,KAAKpD,iBAAL,CAAuBK,gBAAvB,IACApB,WAAW,CAACE,OAAZ,CAAoB6B,aADpB,IAEA,CAAC,KAAKpC,mBAAL,CAFL,EAEgC;AAC9B;AACA,QAAIyE,KAAK,GAAG,CAAZ;AACA,QAAI1C,GAAG,GAAG,IAAV;;AACA,WAAOA,GAAG,IAAI,IAAP,IACLA,GAAG,CAACN,gBADC,IAEL,CAACM,GAAG,CAAC2C,wBAFP,EAEiC;AAC/B,QAAED,KAAF;AACA1C,MAAAA,GAAG,GAAGA,GAAG,CAACX,iBAAV;AACD,KAT6B,CAW9B;;;AACA,QAAIyB,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACuB,MAAN,GAAe,CAApC,EAAuC;AACrC,YAAMO,UAAU,GAAGtF,UAAU,CAACwD,KAAD,CAA7B;;AACA,UAAI8B,UAAU,CAACC,GAAX,KAAmBD,UAAU,CAACE,GAA9B,IAAqCF,UAAU,CAACE,GAAX,GAAiBJ,KAAtD,IAA+DE,UAAU,CAACG,oBAA9E,EAAoG;AAClG,aAAK,IAAIT,CAAC,GAAGM,UAAU,CAACE,GAAxB,EAA6BR,CAAC,GAAGI,KAAjC,EAAwC,EAAEJ,CAA1C,EAA6C;AAC3CxB,UAAAA,KAAK,GAAG,CAACA,KAAD,CAAR;AACD;AACF;AACF;AACF;;AAED,SAAO3D,UAAU,CAACqD,SAAX,CAAqB+B,aAArB,CAAmC5C,IAAnC,CAAwC,IAAxC,EAA8CmB,KAA9C,EAAqDe,KAArD,EAA4DW,IAA5D,EAAkEC,QAAlE,CAAP;AACD,CA1BD;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAnE,WAAW,CAACkC,SAAZ,CAAsBjD,IAAtB,GAA6B,UAASuD,KAAT,EAAgBC,GAAhB,EAAqByB,IAArB,EAA2BQ,IAA3B,EAAiCxE,OAAjC,EAA0C;AACrE;AACAT,EAAAA,aAAa,KAAKA,aAAa,GAAGhB,OAAO,CAAC,UAAD,CAAP,CAAoBuE,KAAzC,CAAb;AAEA,MAAIgB,CAAJ;AACA,MAAIW,CAAJ;;AAEA,MAAI3B,KAAK,CAACC,OAAN,CAAcT,KAAd,CAAJ,EAA0B;AACxB,UAAMsB,GAAG,GAAGtB,KAAK,CAACuB,MAAlB;;AACA,QAAI,CAACD,GAAD,IAAQrB,GAAZ,EAAiB;AACf,YAAMmC,OAAO,GAAGnC,GAAG,CAACoC,MAAJ,CAAWC,YAAX,EAAhB;AAEA,YAAMC,SAAS,GAAG,KAAK7D,IAAvB;;AACA,WAAK8C,CAAC,GAAG,CAAJ,EAAOW,CAAC,GAAGC,OAAO,CAACb,MAAxB,EAAgCC,CAAC,GAAGW,CAApC,EAAuC,EAAEX,CAAzC,EAA4C;AAC1C,cAAMgB,SAAS,GAAGJ,OAAO,CAACZ,CAAD,CAAP,CAAW,CAAX,EAAce,SAAd,CAAlB;;AACA,YAAIC,SAAS,KAAK,UAAd,IAA4BA,SAAS,KAAK,IAA9C,EAAoD;AAClD;AACD;AACF,OATc,CAWf;AACA;;;AACA,YAAMC,gBAAgB,GAAG,KAAK/D,IAAL,CAAUgE,QAAV,CAAmB,cAAnB,IACvB,KAAKhE,IAAL,CAAUiE,MAAV,CAAiB,CAAjB,EAAoB,KAAKjE,IAAL,CAAUkE,WAAV,CAAsB,GAAtB,CAApB,CADuB,GAC2B,IADpD;;AAEA,UAAIH,gBAAgB,IAAI,IAAxB,EAA8B;AAC5B,aAAKjB,CAAC,GAAG,CAAJ,EAAOW,CAAC,GAAGC,OAAO,CAACb,MAAxB,EAAgCC,CAAC,GAAGW,CAApC,EAAuC,EAAEX,CAAzC,EAA4C;AAC1C,gBAAMgB,SAAS,GAAGJ,OAAO,CAACZ,CAAD,CAAP,CAAW,CAAX,EAAciB,gBAAd,CAAlB;;AACA,cAAID,SAAS,KAAK,UAAlB,EAA8B;AAC5B;AACD;AACF;AACF;AACF;;AAED9E,IAAAA,OAAO,GAAGA,OAAO,IAAIL,SAArB;AAEA,QAAI8D,QAAQ,GAAGnB,KAAK,CAACoB,oBAAN,GAA6BpB,KAAK,CAACqB,OAAnC,GAA6CrB,KAA5D;AACAA,IAAAA,KAAK,GAAG/C,aAAa,CAACkE,QAAD,EAAWzD,OAAO,CAACgB,IAAR,IAAgB,KAAKmE,UAArB,IAAmC,KAAKnE,IAAnD,EAAyDuB,GAAzD,EAA8D,IAA9D,CAArB;AACAkB,IAAAA,QAAQ,GAAGnB,KAAK,CAACqB,OAAjB;;AAEA,QAAIK,IAAI,IAAIzB,GAAG,IAAI,IAAf,IAAuBA,GAAG,CAACe,GAAJ,IAAW,IAAlC,IAA0Cf,GAAG,CAACgB,UAAJ,CAAe,KAAKvC,IAApB,CAA9C,EAAyE;AACvE,aAAOsB,KAAP;AACD;;AAED,UAAM3B,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMyE,eAAe,GAAGzE,MAAM,CAACO,gBAA/B;;AACA,QAAIP,MAAM,IAAI,KAAKE,iBAAL,KAA2BhC,KAAzC,EAAgD;AAC9C,UAAI;AACF,cAAM+E,GAAG,GAAGH,QAAQ,CAACI,MAArB;;AACA,aAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,GAAhB,EAAqBE,CAAC,EAAtB,EAA0B;AACxB,gBAAMuB,IAAI,GAAG,EAAb,CADwB,CAExB;AACA;AACA;;AACA,cAAID,eAAJ,EAAqB;AACnB,gBAAIpF,OAAO,CAAC6E,SAAR,IAAqB,IAAzB,EAA+B;AAC7BQ,cAAAA,IAAI,CAACC,cAAL,GAAsBxB,CAAtB;AACD,aAFD,MAEO,IAAInD,MAAM,CAAC4E,gBAAP,IAA2B,IAA/B,EAAqC;AAC1CF,cAAAA,IAAI,CAACC,cAAL,GAAsBxB,CAAtB;AACD;AACF;;AACDL,UAAAA,QAAQ,CAACK,CAAD,CAAR,GAAcnD,MAAM,CAAC6E,YAAP,CAAoB/B,QAAQ,CAACK,CAAD,CAA5B,EAAiCvB,GAAjC,EAAsCyB,IAAtC,EAA4C,KAAK,CAAjD,EAAoDqB,IAApD,CAAd;AACD;AACF,OAhBD,CAgBE,OAAOI,CAAP,EAAU;AACV;AACA,cAAM,IAAI7G,SAAJ,CAAc,MAAM6G,CAAC,CAACC,IAAR,GAAe,GAA7B,EAAkCxG,IAAI,CAACyG,OAAL,CAAarD,KAAb,CAAlC,EAAuD,KAAKtB,IAAL,GAAY,GAAZ,GAAkB8C,CAAzE,EAA4E2B,CAA5E,EAA+E,IAA/E,CAAN;AACD;AACF;;AAED,WAAOnD,KAAP;AACD;;AAED,MAAI0B,IAAI,IAAIlE,WAAW,CAACE,OAAZ,CAAoB6B,aAAhC,EAA+C;AAC7C;AACA;AACA,QAAI,CAAC,CAACU,GAAF,IAAS,CAAC,CAACyB,IAAf,EAAqB;AACnBzB,MAAAA,GAAG,CAACqD,YAAJ,CAAiB,KAAK5E,IAAtB;AACD;;AACD,WAAO,KAAKjC,IAAL,CAAU,CAACuD,KAAD,CAAV,EAAmBC,GAAnB,EAAwByB,IAAxB,CAAP;AACD;;AAED,QAAM,IAAIpF,SAAJ,CAAc,OAAd,EAAuBM,IAAI,CAACyG,OAAL,CAAarD,KAAb,CAAvB,EAA4C,KAAKtB,IAAjD,EAAuD,IAAvD,EAA6D,IAA7D,CAAN;AACD,CAlFD;AAoFA;AACA;AACA;;;AAEAlB,WAAW,CAACkC,SAAZ,CAAsB6D,gBAAtB,GAAyC,SAASA,gBAAT,CAA0BvD,KAA1B,EAAiCC,GAAjC,EAAsC;AAC7E;AACAhD,EAAAA,aAAa,KAAKA,aAAa,GAAGhB,OAAO,CAAC,UAAD,CAAP,CAAoBuE,KAAzC,CAAb;;AAEA,MAAIA,KAAK,CAACC,OAAN,CAAcT,KAAd,CAAJ,EAA0B;AACxB,QAAIwB,CAAJ;AACA,UAAML,QAAQ,GAAGnB,KAAK,CAACqB,OAAN,GAAgBrB,KAAK,CAACqB,OAAtB,GAAgCrB,KAAjD;AACA,UAAMsB,GAAG,GAAGH,QAAQ,CAACI,MAArB;AAEA,UAAMlD,MAAM,GAAG,KAAKA,MAApB;;AACA,QAAIA,MAAM,IAAI,KAAKE,iBAAL,KAA2BhC,KAAzC,EAAgD;AAC9C,UAAI;AACF,aAAKiF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,GAAhB,EAAqBE,CAAC,EAAtB,EAA0B;AACxB,gBAAMuB,IAAI,GAAG,EAAb,CADwB,CAExB;AACA;AACA;;AACA,cAAI1E,MAAM,CAACO,gBAAP,IAA2BP,MAAM,CAAC4E,gBAAP,IAA2B,IAA1D,EAAgE;AAC9DF,YAAAA,IAAI,CAACC,cAAL,GAAsBxB,CAAtB;AACD;;AAEDL,UAAAA,QAAQ,CAACK,CAAD,CAAR,GAAcnD,MAAM,CAAC5B,IAAP,CAAY0E,QAAQ,CAACK,CAAD,CAApB,EAAyBvB,GAAzB,EAA8B,KAA9B,EAAqC,KAAK,CAA1C,EAA6C8C,IAA7C,CAAd;AACD;AACF,OAZD,CAYE,OAAOI,CAAP,EAAU;AACV;AACA,cAAM,IAAI7G,SAAJ,CAAc,MAAM6G,CAAC,CAACC,IAAR,GAAe,GAA7B,EAAkCxG,IAAI,CAACyG,OAAL,CAAarD,KAAb,CAAlC,EAAuD,KAAKtB,IAAL,GAAY,GAAZ,GAAkB8C,CAAzE,EAA4E2B,CAA5E,EAA+E,IAA/E,CAAN;AACD;AACF;;AAED,WAAOnD,KAAP;AACD;;AAED,QAAM,IAAI1D,SAAJ,CAAc,OAAd,EAAuBM,IAAI,CAACyG,OAAL,CAAarD,KAAb,CAAvB,EAA4C,KAAKtB,IAAjD,EAAuD,IAAvD,EAA6D,IAA7D,CAAN;AACD,CAjCD;;AAmCAlB,WAAW,CAACkC,SAAZ,CAAsB8D,SAAtB,GAAkChG,WAAW,CAACkC,SAAZ,CAAsB+D,QAAxD;AAEA;AACA;AACA;;AAEAjG,WAAW,CAACkC,SAAZ,CAAsBgE,aAAtB,GAAsC,UAASxF,IAAT,EAAemE,MAAf,EAAuB;AAC3D,MAAInD,GAAG,GAAG,IAAV;;AACA,SAAOA,GAAG,CAACN,gBAAJ,IAAwB,CAACM,GAAG,CAAC2C,wBAApC,EAA8D;AAC5D3C,IAAAA,GAAG,GAAGA,GAAG,CAACX,iBAAV;;AACA,QAAIW,GAAG,IAAI,IAAP,IAAe,OAAOA,GAAP,KAAe,UAAlC,EAA8C;AAC5C,YAAM,IAAI/C,aAAJ,CAAkB,mDACtB,oBADsB,GACC,KAAKuC,IADN,GACa,mBAD/B,CAAN;AAED;AACF;;AACD,SAAOQ,GAAG,CAACwE,aAAJ,CAAkBxF,IAAlB,EAAwBmE,MAAxB,CAAP;AACD,CAVD;AAYA;AACA;AACA;;;AAEA7E,WAAW,CAACkC,SAAZ,CAAsB1B,KAAtB,GAA8B,YAAW;AACvC,QAAMN,OAAO,GAAGJ,MAAM,CAACqG,MAAP,CAAc,EAAd,EAAkB,KAAKjG,OAAvB,CAAhB;AACA,QAAMkG,UAAU,GAAG,IAAI,KAAKhE,WAAT,CAAqB,KAAKlB,IAA1B,EAAgC,KAAKL,MAArC,EAA6CX,OAA7C,EAAsD,KAAKC,aAA3D,CAAnB;AACAiG,EAAAA,UAAU,CAACC,UAAX,GAAwB,KAAKA,UAAL,CAAgBC,KAAhB,EAAxB;;AACA,MAAI,KAAKC,iBAAL,KAA2BC,SAA/B,EAA0C;AACxCJ,IAAAA,UAAU,CAACG,iBAAX,GAA+B,KAAKA,iBAApC;AACD;;AACD,SAAOH,UAAP;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEApG,WAAW,CAACkC,SAAZ,CAAsBuE,YAAtB,GAAqC,UAASC,YAAT,EAAuBlE,KAAvB,EAA8B;AACjE,MAAImE,OAAJ;AACA,MAAIC,GAAJ;;AAEA,MAAI7D,SAAS,CAACgB,MAAV,KAAqB,CAAzB,EAA4B;AAC1B4C,IAAAA,OAAO,GAAG,KAAKE,oBAAL,CAA0BH,YAA1B,CAAV;;AAEA,QAAI,CAACC,OAAL,EAAc;AACZ,YAAM,IAAI9D,KAAJ,CAAU,gBAAgB6D,YAAhB,GAA+B,cAAzC,CAAN;AACD;;AAEDE,IAAAA,GAAG,GAAGD,OAAO,CAACtF,IAAR,CAAa,IAAb,EAAmBmB,KAAnB,CAAN;AACD,GARD,MAQO;AACLoE,IAAAA,GAAG,GAAGF,YAAN;AACA,QAAII,WAAW,GAAG,KAAK/F,iBAAvB;;AAEA,QAAI6F,GAAG,IACHE,WAAW,CAACC,cADZ,IAEAD,WAAW,CAACjC,MAFZ,IAGAiC,WAAW,CAACjC,MAAZ,CAAmB3E,OAHnB,IAIA4G,WAAW,CAACjC,MAAZ,CAAmB3E,OAAnB,CAA2B8G,gBAJ/B,EAIiD;AAC/C,UAAI,OAAOJ,GAAG,CAACE,WAAW,CAACjC,MAAZ,CAAmB3E,OAAnB,CAA2B8G,gBAA5B,CAAV,KAA4D,QAA5D,IACAF,WAAW,CAACC,cAAZ,CAA2BH,GAAG,CAACE,WAAW,CAACjC,MAAZ,CAAmB3E,OAAnB,CAA2B8G,gBAA5B,CAA9B,CADJ,EACkF;AAChFF,QAAAA,WAAW,GAAGA,WAAW,CAACC,cAAZ,CAA2BH,GAAG,CAACE,WAAW,CAACjC,MAAZ,CAAmB3E,OAAnB,CAA2B8G,gBAA5B,CAA9B,CAAd;AACD,OAHD,MAGO;AACL,cAAMC,kBAAkB,GAAGzH,uBAAuB,CAACsH,WAAW,CAACC,cAAb,EAA6BH,GAAG,CAACE,WAAW,CAACjC,MAAZ,CAAmB3E,OAAnB,CAA2B8G,gBAA5B,CAAhC,CAAlD;;AACA,YAAIC,kBAAJ,EAAwB;AACtBH,UAAAA,WAAW,GAAGG,kBAAd;AACD;AACF;AACF;;AAED,UAAMC,KAAK,GAAG,KAAKnG,iBAAL,CAAuBmB,SAArC;AACA,QAAIiF,MAAM,GAAGD,KAAK,KAAKA,KAAK,CAACT,YAAN,IAAsBS,KAAK,CAACjI,IAAjC,CAAlB;;AACA,QAAI,CAACkI,MAAD,IAAWL,WAAW,CAACL,YAA3B,EAAyC;AACvCU,MAAAA,MAAM,GAAGL,WAAW,CAACL,YAArB;AACD;;AACD,UAAM5F,MAAM,GAAG,KAAKA,MAApB;;AAEA,QAAImC,KAAK,CAACC,OAAN,CAAc2D,GAAd,CAAJ,EAAwB;AACtB,WAAKQ,OAAL,CAAaC,OAAb,GAAuBC,OAAvB,CAA+BC,MAAM,IAAI;AACvCX,QAAAA,GAAG,GAAGW,MAAM,CAAClG,IAAP,CAAY,IAAZ,EAAkBuF,GAAlB,EAAuB,IAAvB,CAAN;AACD,OAFD;AAGAA,MAAAA,GAAG,GAAGA,GAAG,CAACY,GAAJ,CAAQ,UAASC,CAAT,EAAY;AACxB,YAAIpI,KAAK,CAAC6D,QAAN,CAAeuE,CAAf,KAAqBA,CAAC,CAACC,UAA3B,EAAuC;AACrC,iBAAOD,CAAP;AACD;;AACD,YAAIN,MAAJ,EAAY;AACVM,UAAAA,CAAC,GAAGN,MAAM,CAAC9F,IAAP,CAAYR,MAAZ,EAAoB4G,CAApB,CAAJ;AACA,iBAAOA,CAAP;AACD;;AACD,YAAIA,CAAC,IAAI,IAAT,EAAe;AACbA,UAAAA,CAAC,GAAG,IAAIX,WAAJ,CAAgBW,CAAhB,CAAJ;AACA,iBAAOA,CAAP;AACD;;AACD,eAAOA,CAAP;AACD,OAbK,CAAN;AAcD,KAlBD,MAkBO,IAAIN,MAAJ,EAAY;AACjBP,MAAAA,GAAG,GAAGO,MAAM,CAAC9F,IAAP,CAAYR,MAAZ,EAAoB+F,GAApB,CAAN;AACD,KAFM,MAEA,IAAIA,GAAG,IAAI,IAAX,EAAiB;AACtBA,MAAAA,GAAG,GAAG,IAAIE,WAAJ,CAAgBF,GAAhB,CAAN;AACD;AACF;;AAED,SAAOA,GAAP;AACD,CAjED;;AAmEA,SAASe,QAAT,CAAkBf,GAAlB,EAAuB;AACrB,MAAI,CAAC5D,KAAK,CAACC,OAAN,CAAc2D,GAAd,CAAL,EAAyB;AACvBA,IAAAA,GAAG,GAAG,CAACA,GAAD,CAAN;AACD;;AAEDA,EAAAA,GAAG,GAAGA,GAAG,CAACY,GAAJ,CAAQ,UAASC,CAAT,EAAY;AACxB,QAAIpI,KAAK,CAAC6D,QAAN,CAAeuE,CAAf,CAAJ,EAAuB;AACrB,YAAMG,CAAC,GAAG,EAAV;AACAA,MAAAA,CAAC,CAAC,KAAK1G,IAAN,CAAD,GAAeuG,CAAf;AACA,aAAOxI,IAAI,CAAC,KAAK8B,iBAAL,CAAuB8D,MAAxB,EAAgC+C,CAAhC,CAAJ,CAAuC,KAAK1G,IAA5C,CAAP;AACD;;AACD,WAAOuG,CAAP;AACD,GAPK,EAOH,IAPG,CAAN;AASA,SAAO,KAAKhB,YAAL,CAAkBG,GAAlB,CAAP;AACD;;AAED,SAASiB,cAAT,CAAwBjB,GAAxB,EAA6B;AAC3B,QAAMkB,IAAI,GAAGhI,MAAM,CAACgI,IAAP,CAAYlB,GAAZ,CAAb;AACA,QAAMmB,OAAO,GAAGD,IAAI,CAAC/D,MAArB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+D,OAApB,EAA6B,EAAE/D,CAA/B,EAAkC;AAChC,UAAM/D,GAAG,GAAG6H,IAAI,CAAC9D,CAAD,CAAhB;AACA,UAAMxB,KAAK,GAAGoE,GAAG,CAAC3G,GAAD,CAAjB;;AACA,QAAId,UAAU,CAACc,GAAD,CAAV,IAAmBuC,KAAK,IAAI,IAAhC,EAAsC;AACpCoE,MAAAA,GAAG,CAAC3G,GAAD,CAAH,GAAW,KAAKwG,YAAL,CAAkBxG,GAAlB,EAAuBuC,KAAvB,CAAX;AACD;AACF,GAT0B,CAW3B;AACA;;;AACA,QAAMwE,gBAAgB,GAAG9H,GAAG,CAAC,IAAD,EAC1B,mDAD0B,CAA5B;AAEA,QAAM6H,cAAc,GAAG7H,GAAG,CAAC,IAAD,EAAO,yCAAP,EAAkD,EAAlD,CAA1B;;AACA,MAAI8H,gBAAgB,IAAI,IAApB,IACAJ,GAAG,CAACI,gBAAD,CAAH,IAAyB,IADzB,IAEAD,cAAc,CAACH,GAAG,CAACI,gBAAD,CAAJ,CAAd,IAAyC,IAF7C,EAEmD;AACjD,WAAO/H,IAAI,CAAC8H,cAAc,CAACH,GAAG,CAACI,gBAAD,CAAJ,CAAf,EAAwCJ,GAAxC,CAAX;AACD;;AAED,SAAO3H,IAAI,CAAC,KAAK8B,iBAAL,CAAuB8D,MAAxB,EAAgC+B,GAAhC,CAAX;AACD;;AAED,MAAMoB,MAAM,GAAGhI,WAAW,CAACkC,SAAZ,CAAsB2E,oBAAtB,GAA6C,EAA5D;AAEAmB,MAAM,CAACC,IAAP,GAAcN,QAAd;AACAK,MAAM,CAACE,QAAP,GAAkBC,MAAlB;AACAH,MAAM,CAACN,UAAP,GAAoBG,cAApB;AACAG,MAAM,CAACI,cAAP,GAAwB7I,UAAU,CAAC8I,kBAAnC;AACAL,MAAM,CAACM,GAAP,GAAaC,iCAAiC,CAAC,KAAD,CAA9C;AACAP,MAAM,CAACQ,IAAP,GAAcD,iCAAiC,CAAC,MAAD,CAA/C;AACAP,MAAM,CAACS,IAAP,GAAcF,iCAAiC,CAAC,MAAD,CAA/C;;AAEA,SAASA,iCAAT,CAA2CG,EAA3C,EAA+C;AAC7C,SAAO,SAASC,2BAAT,CAAqC/B,GAArC,EAA0C;AAC/C,QAAI,CAAC5D,KAAK,CAACC,OAAN,CAAc2D,GAAd,CAAL,EAAyB;AACvB,YAAM,IAAIgC,SAAJ,CAAc,iBAAiBF,EAAjB,GAAsB,oBAApC,CAAN;AACD;;AAED,UAAMhF,GAAG,GAAG,EAAZ;;AACA,SAAK,MAAMmF,GAAX,IAAkBjC,GAAlB,EAAuB;AACrBlD,MAAAA,GAAG,CAACoF,IAAJ,CAAS7J,IAAI,CAAC,KAAK8B,iBAAL,CAAuB8D,MAAxB,EAAgCgE,GAAhC,CAAb;AACD;;AAED,WAAOnF,GAAP;AACD,GAXD;AAYD;;AAEDsE,MAAM,CAACe,KAAP,GACAf,MAAM,CAACgB,WAAP,GAAqBzJ,UAAU,CAAC0J,SADhC;AAGAjB,MAAM,CAACkB,OAAP,GACAlB,MAAM,CAACmB,UAAP,GAAoB5J,UAAU,CAAC6J,WAD/B;AAGApB,MAAM,CAACqB,KAAP,GACArB,MAAM,CAACsB,YAAP,GACAtB,MAAM,CAACuB,YAAP,GAAsBjK,YAFtB;AAIA0I,MAAM,CAACxJ,OAAP,GAAiBA,OAAjB;AACAwJ,MAAM,CAACtJ,KAAP,GAAeA,KAAf;AAEAsJ,MAAM,CAACwB,GAAP,GACAxB,MAAM,CAACyB,GAAP,GACAzB,MAAM,CAAC0B,IAAP,GACA1B,MAAM,CAAC2B,GAAP,GACA3B,MAAM,CAAC4B,IAAP,GACA5B,MAAM,CAAC6B,GAAP,GACA7B,MAAM,CAAC8B,MAAP,GAAgB9J,WAAW,CAACkC,SAAZ,CAAsBuE,YANtC,C,CAQA;AACA;;AACAuB,MAAM,CAAC+B,IAAP,GAAclL,UAAU,CAACqD,SAAX,CAAqB2E,oBAArB,CAA0CkD,IAAxD;AACA/B,MAAM,CAACgC,GAAP,GAAanL,UAAU,CAACqD,SAAX,CAAqB2E,oBAArB,CAA0CmD,GAAvD;AAEA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAP,GAAiBlK,WAAjB","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst get = require('../helpers/get');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      let arr = [];\n      if (fn) {\n        arr = defaultArr.call(this);\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      }\n      // Leave it up to `cast()` to convert the array\n      return arr;\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * ####Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = get(arr, 'caster.instance');\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  if (Array.isArray(ret)) {\n    const rawValue = ret.isMongooseArrayProxy ? ret.__array : ret;\n    const len = rawValue.length;\n    for (let i = 0; i < len; ++i) {\n      rawValue[i] = this.caster.applyGetters(rawValue[i], scope);\n    }\n  }\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr.$isMongooseArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length > 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substr(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n\n    let rawValue = value.isMongooseArrayProxy ? value.__array : value;\n    value = MongooseArray(rawValue, options.path || this._arrayPath || this.path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * Ignore\n */\n\nSchemaArray.prototype.discriminator = function(name, schema) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(name, schema);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function(v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function(v) {\n    if (utils.isObject(v)) {\n      const o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n    return v;\n  }, this);\n\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = get(this,\n    'casterConstructor.schema.options.discriminatorKey');\n  const discriminators = get(this, 'casterConstructor.schema.discriminators', {});\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema, obj));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$ne =\nhandle.$regex = SchemaArray.prototype.castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"]},"metadata":{},"sourceType":"script"}