{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst InternalCache = require('./internal');\n\nconst MongooseError = require('./error/index');\n\nconst MixedSchema = require('./schema/mixed');\n\nconst ObjectExpectedError = require('./error/objectExpected');\n\nconst ObjectParameterError = require('./error/objectParameter');\n\nconst ParallelValidateError = require('./error/parallelValidate');\n\nconst Schema = require('./schema');\n\nconst StrictModeError = require('./error/strict');\n\nconst ValidationError = require('./error/validation');\n\nconst ValidatorError = require('./error/validator');\n\nconst VirtualType = require('./virtualtype');\n\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\n\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\n\nconst compile = require('./helpers/document/compile').compile;\n\nconst defineKey = require('./helpers/document/compile').defineKey;\n\nconst flatten = require('./helpers/common').flatten;\n\nconst flattenObjectWithDottedPaths = require('./helpers/path/flattenObjectWithDottedPaths');\n\nconst get = require('./helpers/get');\n\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\n\nconst getKeysInSchemaOrder = require('./helpers/schema/getKeysInSchemaOrder');\n\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\n\nconst immediate = require('./helpers/immediate');\n\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\n\nconst isExclusive = require('./helpers/projection/isExclusive');\n\nconst inspect = require('util').inspect;\n\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\n\nconst markArraySubdocsPopulated = require('./helpers/populate/markArraySubdocsPopulated');\n\nconst mpath = require('mpath');\n\nconst queryhelpers = require('./queryhelpers');\n\nconst utils = require('./utils');\n\nconst isPromise = require('./helpers/isPromise');\n\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = require('./helpers/symbols').arrayAtomicsBackupSymbol;\n\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\n\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\n\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\n\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\n\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\n\nconst getSymbol = require('./helpers/symbols').getSymbol;\n\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\n\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\n\nconst schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;\n\nconst parentPaths = require('./helpers/path/parentPaths');\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\nconst specialProperties = utils.specialProperties;\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n\n  options = Object.assign({}, options); // Support `browserDocument.js` syntax\n\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;\n\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache();\n  this.$__.emitter = new EventEmitter();\n  this.$isNew = 'isNew' in options ? options.isNew : true;\n\n  if ('priorDoc' in options) {\n    this.$__.priorDoc = options.priorDoc;\n  }\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  let defaults = true;\n\n  if (options.defaults !== undefined) {\n    this.$__.defaults = options.defaults;\n    defaults = options.defaults;\n  }\n\n  const schema = this.$__schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options.strict;\n\n    if (fields !== undefined) {\n      this.$__.selected = fields;\n    }\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n  let exclude = null; // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (utils.isPOJO(fields)) {\n    exclude = isExclusive(fields);\n  }\n\n  const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : {};\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false); // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n\n    if (defaults) {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {\n        isNew: this.$isNew\n      });\n    }\n  }\n\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true);\n    } else {\n      this.$set(obj, undefined, true);\n    }\n\n    if (obj instanceof Document) {\n      this.$isNew = obj.$isNew;\n    }\n  } // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n\n\n  if (options.willInit && defaults) {\n    EventEmitter.prototype.once.call(this, 'init', () => {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n        isNew: this.$isNew\n      });\n    });\n  } else if (defaults) {\n    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n      isNew: this.$isNew\n    });\n  }\n\n  this.$__._id = this._id;\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n\n    const keys = Object.keys(this._doc);\n    keys.forEach(function (key) {\n      if (!(key in schema.tree)) {\n        defineKey({\n          prop: key,\n          subprops: null,\n          prototype: _this\n        });\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\nObject.defineProperty(Document.prototype, 'isNew', {\n  get: function () {\n    return this.$isNew;\n  },\n  set: function (value) {\n    this.$isNew = value;\n  }\n});\nObject.defineProperty(Document.prototype, 'errors', {\n  get: function () {\n    return this.$errors;\n  },\n  set: function (value) {\n    this.$errors = value;\n  }\n});\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\n\nutils.each(['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners', 'removeAllListeners', 'addListener'], function (emitterFn) {\n  Document.prototype[emitterFn] = function () {\n    return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n  };\n\n  Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\n});\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__schema;\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * ####Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  get: function () {\n    if (this.$__.locals == null) {\n      this.$__.locals = {};\n    }\n\n    return this.$__.locals;\n  },\n  set: function (v) {\n    this.$__.locals = v;\n  }\n});\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property $isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$isNew;\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.isNew;\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * ####Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n/**\n * Hash containing current validation $errors.\n *\n * @api public\n * @property $errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$errors;\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.errors;\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * ####Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$op', {\n  get: function () {\n    return this.$__.op || null;\n  },\n  set: function (value) {\n    this.$__.op = value;\n  }\n});\n/*!\n * ignore\n */\n\nfunction $__hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n\n  for (const key of keys) {\n    const parts = key.split('.');\n    const c = [];\n\n    for (const part of parts) {\n      c.push(part);\n      hasIncludedChildren[c.join('.')] = 1;\n    }\n  }\n\n  return hasIncludedChildren;\n}\n/*!\n * ignore\n */\n\n\nfunction $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && skipId) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (typeof type.defaultValue === 'function') {\n          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n            break;\n          }\n\n          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n            break;\n          }\n        } else if (!isBeforeSetters) {\n          // Non-function defaults should always run **before** setters\n          continue;\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            doc.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction $applyDefaultsToNested(val, path, doc) {\n  if (val == null) {\n    return;\n  }\n\n  flattenObjectWithDottedPaths(val);\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    if (!p.startsWith(path + '.')) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const pieces = type.splitPath().slice(pathPieces.length);\n    const len = pieces.length;\n\n    if (type.defaultValue === void 0) {\n      continue;\n    }\n\n    let cur = val;\n\n    for (let j = 0; j < len; ++j) {\n      if (cur == null) {\n        break;\n      }\n\n      const piece = pieces[j];\n\n      if (j === len - 1) {\n        if (cur[piece] !== void 0) {\n          break;\n        }\n\n        try {\n          const def = type.getDefault(doc, false);\n\n          if (def !== void 0) {\n            cur[piece] = def;\n          }\n        } catch (err) {\n          doc.invalidate(path + '.' + curPath, err);\n          break;\n        }\n\n        break;\n      }\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n      cur[piece] = cur[piece] || {};\n      cur = cur[piece];\n    }\n  }\n}\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__buildDoc = function (obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n  const paths = Object.keys(this.$__schema.paths). // Don't build up any paths that are underneath a map, we don't know\n  // what the keys will be\n  filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n      curPath += (!curPath.length ? '' : '.') + piece; // support excluding intermediary levels\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n/*!\n * Converts to POJO when you use the document for querying\n */\n\n\nDocument.prototype.toBSON = function () {\n  return this.toObject(internalToObjectOptions);\n};\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.init = function (doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\nDocument.prototype.$init = function () {\n  return this.constructor.prototype.init.apply(this, arguments);\n};\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__init = function (doc, opts) {\n  this.$isNew = false;\n  this.$init = true;\n  opts = opts || {}; // handle docs with populated paths\n  // If doc._id is not null or undefined\n\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.$populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n\n        child.$__.parent = this;\n      }\n\n      item._childDocs = [];\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n  markArraySubdocsPopulated(this, opts.populated);\n  this.$emit('init', this);\n  this.constructor.emit('init', this);\n  this.$__._id = this._id;\n  return this;\n};\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schema;\n  let path;\n  let i;\n  let index = 0;\n  const strict = self.$__.strictMode;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.$__schema.path(path); // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n\n    if (self.$__schema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    if (!schema && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schema) {\n      doc[i] = obj[i];\n\n      if (!strict) {\n        self[i] = obj[i];\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\n        delete doc[i];\n      }\n\n      if (obj[i] === null) {\n        doc[i] = schema._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const intCache = obj[i].$__ || {};\n        const wasPopulated = intCache.wasPopulated || null;\n\n        if (schema && !wasPopulated) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      } // mark as hydrated\n\n\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.update = function update() {\n  const args = utils.args(arguments);\n  args.unshift({\n    _id: this._id\n  });\n  const query = this.constructor.update.apply(this.constructor, args);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  return query;\n};\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model.updateOne)\n *\n * @see Model.updateOne #model_Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({\n    _id: this._id\n  }, doc, options);\n  query.pre(cb => {\n    this.constructor._middleware.execPre('updateOne', this, [this], cb);\n  });\n  query.post(cb => {\n    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * ####Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model.replaceOne)\n *\n * @see Model.replaceOne #model_Model.replaceOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = utils.args(arguments);\n  args.unshift({\n    _id: this._id\n  });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * ####Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n\n    return this.$__.session;\n  }\n\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' + 'called `endSession()` on the session you are passing to `$session()`.');\n  }\n\n  this.$__.session = session;\n\n  if (!this.ownerDocument) {\n    const subdocs = this.$getAllSubdocs();\n\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @name overwrite\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    } // Explicitly skip version key\n\n\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @method $set\n * @name $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  options = options || {};\n  const merge = options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  const typeKey = this.$__schema.options.typeKey;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n  const strict = 'strict' in options ? options.strict : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  if (path == null) {\n    [path, val] = [val, path];\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n\n    if (path == null) {\n      [path, val] = [val, path];\n    }\n\n    prefix = val ? val + '.' : '';\n    keys = getKeysInSchemaOrder(this.$__schema, path);\n    const len = keys.length; // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n\n    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);\n\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n\n      if (val) {\n        this.$set(val, {});\n      }\n\n      return this;\n    }\n\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix + key;\n      pathtype = this.$__schema.pathType(pathName);\n      const valForKey = path[key]; // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n\n      if (type === true && !prefix && path[key] != null && pathtype === 'nested' && this._doc[key] != null) {\n        delete this._doc[key]; // Make sure we set `{}` back even if we minimize re: gh-8565\n\n        options = Object.assign({}, options, {\n          _skipMinimizeTopLevel: true\n        });\n      } else {\n        // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441\n        options = Object.assign({}, options, {\n          _skipMinimizeTopLevel: false\n        });\n      }\n\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\n        $applyDefaultsToNested(path[key], prefix + key, this);\n        this.$set(prefix + key, path[key], constructing, Object.assign({}, options, {\n          _skipMarkModified: true\n        }));\n        continue;\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && path[key] === void 0 && this.$get(pathName) !== void 0) {\n          continue;\n        }\n\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, {\n            typeOnly: true\n          });\n        }\n\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          // Check for setting single embedded schema to document (gh-3535)\n          let p = path[key];\n\n          if (this.$__schema.paths[pathName] && this.$__schema.paths[pathName].$isSingleNested && path[key] instanceof Document) {\n            p = p.toObject({\n              virtuals: false,\n              transform: false\n            });\n          }\n\n          this.$set(prefix + key, p, constructing, options);\n        } else if (pathtype === 'nested' && path[key] instanceof Document) {\n          this.$set(prefix + key, path[key].toObject({\n            transform: false\n          }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, path[key]);\n          } else {\n            throw new StrictModeError(key);\n          }\n        }\n      } else if (path[key] !== void 0) {\n        this.$set(prefix + key, path[key], constructing, options);\n      }\n    } // Ensure all properties are in correct order by deleting and recreating every property.\n\n\n    for (const key of Object.keys(this.$__schema.tree)) {\n      if (this._doc.hasOwnProperty(key)) {\n        const val = this._doc[key];\n        delete this._doc[key];\n        this._doc[key] = val;\n      }\n    }\n\n    return this;\n  }\n\n  let pathType = this.$__schema.pathType(path);\n\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, {\n      typeOnly: true\n    });\n  } // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n\n\n  val = handleSpreadDoc(val); // if this doc is being constructed we should not trigger getters\n\n  const priorVal = (() => {\n    if (this.$__.priorDoc != null) {\n      return this.$__.priorDoc.$__getValue(path);\n    }\n\n    if (constructing) {\n      return void 0;\n    }\n\n    return this.$__getValue(path);\n  })();\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const initialVal = this.$__getValue(path);\n        this.$__.savedState[path] = initialVal;\n        const keys = Object.keys(initialVal || {});\n\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = initialVal[key];\n        }\n      }\n\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\n      this.$__setValue(path, {});\n\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing, options);\n      }\n\n      if (priorVal != null && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n\n      cleanModifiedSubpaths(this, path, {\n        skipDocArrays: true\n      });\n      return this;\n    }\n\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.'); // Might need to change path for top-level alias\n\n  if (typeof this.$__schema.aliases[parts[0]] == 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.'); // If path is underneath a virtual, bypass everything and just set it.\n\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.$__schema.path(subpath);\n\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  } // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n\n\n  let cur = this._doc;\n  let curPath = '';\n\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length > 0 ? '.' : '') + parts[i];\n\n    if (!cur) {\n      this.$set(curPath, {}); // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark; // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      if (this.$get(subpath, null, {\n        getters: false\n      }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  if (!schema) {\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n    return this;\n  } // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n\n\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (schema.$isSingleNested && val != null && merge) {\n    if (val instanceof Document) {\n      val = val.toObject({\n        virtuals: false,\n        transform: false\n      });\n    }\n\n    const keys = Object.keys(val);\n\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n\n      if (!(val instanceof Document)) {\n        return false;\n      }\n\n      const model = val.constructor; // Check ref\n\n      const ref = schema.options.ref;\n\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      } // Check refPath\n\n\n      const refPath = schema.options.refPath;\n\n      if (refPath == null) {\n        return false;\n      }\n\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n\n    if (refMatches && val instanceof Document) {\n      this.$populated(path, val._id, {\n        [populateModelSymbol]: val.constructor\n      });\n      val.$__.wasPopulated = true;\n      didPopulate = true;\n    }\n\n    let popOpts;\n\n    if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = {\n        [populateModelSymbol]: val[0].constructor\n      };\n      this.$populated(path, val.map(function (v) {\n        return v._id;\n      }), popOpts);\n\n      for (const doc of val) {\n        doc.$__.wasPopulated = true;\n      }\n\n      didPopulate = true;\n    }\n\n    if (this.$__schema.singleNestedPaths[path] == null) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      val = schema.applySetters(val, this, false, priorVal);\n    }\n\n    if (schema.$isMongooseDocumentArray && Array.isArray(val) && val.length > 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n\n      for (const populatedPath of populatedPaths) {\n        this.$populated(path + '.' + populatedPath, val.map(v => v.$populated(populatedPath)), val[0].$__.populated[populatedPath].options);\n      }\n\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val.set(i, val[i]._id, true);\n          }\n        }\n      }\n\n      delete this.$__.populated[path];\n    }\n\n    if (schema.$isSingleNested && val != null) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n\n      if (e.$originalErrorPath) {\n        this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));\n    }\n\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    const doc = this.ownerDocument ? this.ownerDocument() : this;\n    const savedState = doc.$__.savedState;\n    const savedStatePath = this.ownerDocument ? this.$__.fullPath + '.' + path : path;\n\n    if (savedState != null) {\n      const firstDot = savedStatePath.indexOf('.');\n      const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\n\n      if (!savedState.hasOwnProperty(topLevelPath)) {\n        savedState[topLevelPath] = utils.clone(doc.$__getValue(topLevelPath));\n      }\n    }\n\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (savedState != null && savedState.hasOwnProperty(savedStatePath) && utils.deepEqual(val, savedState[savedStatePath])) {\n      this.unmarkModified(path);\n    }\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n\n    const modelName = el.constructor.modelName;\n\n    if (modelName == null) {\n      return false;\n    }\n\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.set = Document.prototype.$set;\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function (pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  if (options._skipMarkModified) {\n    return false;\n  }\n\n  if (this.$isNew) {\n    return true;\n  } // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n\n\n  if (this.$__schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  } // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n\n\n  if (this.$populated(path) && val instanceof Document && deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {\n    return true;\n  }\n\n  if (!constructing && val !== null && val !== undefined && path in this.$__.activePaths.states.default && deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n\n  return false;\n};\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__set = function (pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/ArraySubdocument');\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n  const _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark); // handle directly setting arrays (gh-1126)\n\n    MongooseArray || (MongooseArray = require('./types/array'));\n\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val); // Update embedded document parent references (gh-5189)\n\n\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function (item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      } // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n\n\n      this.$__.activePaths.forEach(function (modifiedPath) {\n        if (modifiedPath.startsWith(path + '.')) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  } else if (Array.isArray(val) && val.isMongooseArray && Array.isArray(priorVal) && priorVal.isMongooseArray) {\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += cur ? '.' + parts[i] : parts[i];\n\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\n\nDocument.prototype.$__getValue = function (path) {\n  return utils.getValue(path, this._doc);\n};\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\n\nDocument.prototype.$__setValue = function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @api public\n */\n\n\nDocument.prototype.get = function (path, type, options) {\n  let adhoc;\n  options = options || {};\n\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  let schema = this.$__path(path);\n\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n  }\n\n  if (schema instanceof MixedSchema) {\n    const virtual = this.$__schema.virtualpath(path);\n\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n\n  const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let obj = this._doc;\n\n  if (schema instanceof VirtualType) {\n    return schema.applyGetters(void 0, this);\n  } // Might need to change path for top-level alias\n\n\n  if (typeof this.$__schema.aliases[pieces[0]] == 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], {\n        getters: false\n      });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, {\n      path: path\n    });\n  }\n\n  return obj;\n};\n/*!\n * ignore\n */\n\n\nDocument.prototype[getSymbol] = Document.prototype.get;\nDocument.prototype.$get = Document.prototype.get;\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function (path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n\n  return this.$__schema.path(path);\n};\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\n\nDocument.prototype.markModified = function (path, scope) {\n  this.$__.activePaths.modify(path);\n\n  if (scope != null && !this.ownerDocument) {\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\n\nDocument.prototype.unmarkModified = function (path) {\n  this.$__.activePaths.init(path);\n\n  if (this.$__.pathsToScopes != null) {\n    delete this.$__.pathsToScopes[path];\n  }\n};\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\n\nDocument.prototype.$ignore = function (path) {\n  this.$__.activePaths.ignore(path);\n};\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * ####Example\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {Array}\n * @api public\n */\n\n\nDocument.prototype.directModifiedPaths = function () {\n  return Object.keys(this.$__.activePaths.states.modify);\n};\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * ####Example:\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\n\nDocument.prototype.$isEmpty = function (path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length > 0) {\n    const v = this.$get(path);\n\n    if (v == null) {\n      return true;\n    }\n\n    if (typeof v !== 'object') {\n      return false;\n    }\n\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {Array}\n * @api public\n */\n\n\nDocument.prototype.modifiedPaths = function (options) {\n  options = options || {};\n  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n\n  const _this = this;\n\n  return directModifiedPaths.reduce(function (list, path) {\n    const parts = path.split('.');\n    list = list.concat(parts.reduce(function (chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function (chain) {\n      return list.indexOf(chain) === -1;\n    }));\n\n    if (!options.includeChildren) {\n      return list;\n    }\n\n    let cur = _this.$get(path);\n\n    if (cur != null && typeof cur === 'object') {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n\n      if (Array.isArray(cur)) {\n        const len = cur.length;\n\n        for (let i = 0; i < len; ++i) {\n          if (list.indexOf(path + '.' + i) === -1) {\n            list.push(path + '.' + i);\n\n            if (cur[i] != null && cur[i].$__) {\n              const modified = cur[i].modifiedPaths();\n\n              for (const childPath of modified) {\n                list.push(path + '.' + i + '.' + childPath);\n              }\n            }\n          }\n        }\n      } else {\n        Object.keys(cur).filter(function (key) {\n          return list.indexOf(path + '.' + key) === -1;\n        }).forEach(function (key) {\n          list.push(path + '.' + key);\n        });\n      }\n    }\n\n    return list;\n  }, []);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function (paths, modifiedPaths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    const isModifiedChild = paths.some(function (path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function (path) {\n      return directModifiedPaths.some(function (mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\nDocument.prototype.$isModified = Document.prototype.isModified;\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.default.hasOwnProperty(path);\n  }\n\n  let paths = path;\n\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.default.hasOwnProperty(path));\n};\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * ####Example:\n *     const product = await product.remove();\n *     product.$isDeleted(); // true\n *     product.remove(); // no-op, doesn't send anything to the db\n *\n *     product.$isDeleted(false);\n *     product.$isDeleted(); // false\n *     product.remove(); // will execute a remove against the db\n *\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.$isDeleted = function (val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isDirectModified = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.modify.hasOwnProperty(path);\n  }\n\n  let paths = path;\n\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.modify.hasOwnProperty(path));\n};\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isInit = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.init.hasOwnProperty(path);\n  }\n\n  let paths = path;\n\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.init.hasOwnProperty(path));\n};\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     const doc = await Thing.findOne().select('name');\n *     doc.isSelected('name') // true\n *     doc.isSelected('age')  // false\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n\n  const pathDot = path + '.';\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n\n  return !inclusive;\n};\n\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * ####Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n\n  return !inclusive;\n};\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\n\nDocument.prototype.validate = function (pathsToValidate, options, callback) {\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.ownerDocument != null) {// Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack\n    });\n  }\n\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      callback = null;\n      pathsToValidate = null;\n    } else if (typeof arguments[0] === 'function') {\n      callback = arguments[0];\n      options = null;\n      pathsToValidate = null;\n    }\n  } else if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = pathsToValidate;\n    pathsToValidate = null;\n  }\n\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n\n  return promiseOrCallback(callback, cb => {\n    if (parallelValidate != null) {\n      return cb(parallelValidate);\n    }\n\n    this.$__validate(pathsToValidate, options, error => {\n      this.$op = null;\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n\nDocument.prototype.$validate = Document.prototype.validate;\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  Object.keys(doc.$__.activePaths.states.require).forEach(path => {\n    const p = doc.$__schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\n      doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n    }\n  });\n}\n/*!\n * ignore\n */\n\n\nfunction _getPathsToValidate(doc) {\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc); // only validate required fields when necessary\n\n\n  let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function (path) {\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\n      return false;\n    }\n\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n\n    return true;\n  }));\n  Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);\n\n  function addToPaths(p) {\n    paths.add(p);\n  }\n\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc\n      for (const p of paths) {\n        if (p === null || p.startsWith(subdoc.$basePath + '.')) {\n          paths.delete(p);\n        }\n      }\n\n      if (doc.$isModified(subdoc.$basePath, modifiedPaths) && !doc.isDirectModified(subdoc.$basePath) && !doc.$isDefault(subdoc.$basePath)) {\n        paths.add(subdoc.$basePath);\n        skipSchemaValidators[subdoc.$basePath] = true;\n      }\n    }\n  } // from here on we're not removing items from paths\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n\n    if (!_pathType || !_pathType.$isMongooseArray || // To avoid potential performance issues, skip doc arrays whose children\n    // are not required. `getPositionalPathType()` may be slow, so avoid\n    // it unless we have a case of #6364\n    _pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required')) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = {\n    skipArrays: true\n  };\n\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({\n          transform: false\n        });\n      }\n\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n\n    const _pathType = doc.$__schema.path(path);\n\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n\n    if (val == null) {\n      continue;\n    }\n\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, skipSchemaValidators];\n}\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__validate = function (pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  const pathsToSkip = get(options, 'pathsToSkip', null);\n  let shouldValidateModifiedOnly;\n\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = undefined;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n\n      for (const errPath of errors) {\n        if (!this.$isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.$emit('validate', _this);\n    this.constructor.emit('validate', _this);\n    this.$__.validating = null;\n\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  }; // only validate required fields when necessary\n\n\n  const pathDetails = _getPathsToValidate(this);\n\n  let paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.$isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (pathsToSkip) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n\n  if (paths.length === 0) {\n    return immediate(function () {\n      const error = _complete();\n\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], {\n          error: error\n        }, function (error) {\n          callback(error);\n        });\n      }\n\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  for (const path of paths) {\n    validatePath(path);\n  }\n\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n    immediate(function () {\n      const schemaType = _this.$__schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      } // If user marked as invalid or there was a cast error, don't validate\n\n\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      } // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n\n\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n\n      let val = _this.$__getValue(path); // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n\n\n      let pop;\n\n      if (pop = _this.$populated(path)) {\n        val = pop;\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\n        // so in that case pull out the document's id\n        val = val._id;\n      }\n\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;\n      const doValidateOptions = {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n      schemaType.doValidate(val, function (err) {\n        if (err) {\n          const isSubdoc = schemaType.$isSingleNested || schemaType.$isArraySubdocument || schemaType.$isMongooseDocumentArray;\n\n          if (isSubdoc && err instanceof ValidationError) {\n            return --total || complete();\n          }\n\n          _this.invalidate(path, err, undefined, true);\n        }\n\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n\n  function complete() {\n    const error = _complete();\n\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], {\n        error: error\n      }, function (error) {\n        callback(error);\n      });\n    }\n\n    callback(null, _this);\n  }\n};\n/*!\n * ignore\n */\n\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n\n  const parentPaths = new Map([]);\n\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n\n    const pieces = path.split('.');\n    let cur = pieces[0];\n\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = [];\n\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.push(path);\n    } else if (parentPaths.has(path)) {\n      ret.push(parentPaths.get(path));\n    }\n  }\n\n  return ret;\n}\n/*!\n * ignore\n */\n\n\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = paths.filter(p => !pathsToSkip.has(p));\n  return paths;\n}\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\n\nDocument.prototype.validateSync = function (pathsToValidate, options) {\n  const _this = this;\n\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  let shouldValidateModifiedOnly;\n\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  let pathsToSkip = options && options.pathsToSkip;\n\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  } // only validate required fields when necessary\n\n\n  const pathDetails = _getPathsToValidate(this);\n\n  let paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.$isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n\n  const validating = {};\n  paths.forEach(function (path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    const p = _this.$__schema.path(path);\n\n    if (!p) {\n      return;\n    }\n\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    const val = _this.$__getValue(path);\n\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n\n    if (err) {\n      const isSubdoc = p.$isSingleNested || p.$isArraySubdocument || p.$isMongooseDocumentArray;\n\n      if (isSubdoc && err instanceof ValidationError) {\n        return;\n      }\n\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n\n  _this.$emit('validate', _this);\n\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\n\nDocument.prototype.invalidate = function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\n\nDocument.prototype.$markValid = function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n/*!\n * ignore\n */\n\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key); // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](/docs/api.html#document_Document-isNew) is `true`,\n * or sends an [updateOne](/docs/api.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * ####Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](api.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|Array<String>} path the field to check\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\n\nDocument.prototype.$isValid = function (path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n\n  if (path == null) {\n    return false;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n\n  return this.$__.validationError.errors[path] == null;\n};\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n  this.$__.activePaths.map('init', 'modify', function (i) {\n    return _this.$__getValue(i);\n  }).filter(function (val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).forEach(function (array) {\n    let i = array.length;\n\n    while (i--) {\n      const doc = array[i];\n\n      if (!doc) {\n        continue;\n      }\n\n      doc.$__reset();\n    }\n\n    _this.$__.activePaths.init(array.$path());\n\n    array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n    array[arrayAtomicsSymbol] = {};\n  });\n  this.$__.activePaths.map('init', 'modify', function (i) {\n    return _this.$__getValue(i);\n  }).filter(function (val) {\n    return val && val.$isSingleNested;\n  }).forEach(function (doc) {\n    doc.$__reset();\n\n    if (doc.$parent() === _this) {\n      _this.$__.activePaths.init(doc.$basePath);\n    } else if (doc.$parent() != null && doc.$parent().ownerDocument) {\n      // If map path underneath subdocument, may end up with a case where\n      // map path is modified but parent still needs to be reset. See gh-10295\n      doc.$parent().$__reset();\n    }\n  }); // clear atomics\n\n  this.$__dirty().forEach(function (dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.states.modify),\n    default: Object.assign({}, this.$__.activePaths.states.default)\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.$errors; // Clear 'dirty' cache\n\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.$errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function (path) {\n    _this.$__.activePaths.require(path);\n  });\n  return this;\n};\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n  this.$__.validationError = this.$__.backup.validationError;\n  this.$errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__dirty = function () {\n  const _this = this;\n\n  let all = this.$__.activePaths.map('modify', function (path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }); // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n\n  all = all.concat(this.$__.activePaths.map('default', function (path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n  const allPaths = new Map(all.filter(el => el != null).map(el => [el.path, el.value])); // Ignore \"foo.a\" if \"foo\" is dirty already.\n\n  const minimal = [];\n  all.forEach(function (item) {\n    if (!item) {\n      return;\n    }\n\n    let top = null;\n    const array = parentPaths(item.path);\n\n    for (let i = 0; i < array.length - 1; i++) {\n      if (allPaths.has(array[i])) {\n        top = allPaths.get(array[i]);\n        break;\n      }\n    }\n\n    if (top == null) {\n      minimal.push(item);\n    } else if (top != null && top[arrayAtomicsSymbol] != null && top.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being set.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top[arrayAtomicsSymbol] = {};\n      top[arrayAtomicsSymbol].$set = top;\n    }\n  });\n  return minimal;\n};\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__setSchema = function (schema) {\n  compile(schema.tree, this, undefined, schema.options); // Apply default getters if virtual doesn't have any (gh-6262)\n\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__getArrayPathsToValidate = function () {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray')); // validate all document arrays.\n\n  return this.$__.activePaths.map('init', 'modify', function (i) {\n    return this.$__getValue(i);\n  }.bind(this)).filter(function (val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function (seed, array) {\n    return seed.concat(array);\n  }, []).filter(function (doc) {\n    return doc;\n  });\n};\n/**\n * Get all subdocs (by bfs)\n *\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$getAllSubdocs = function () {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n  Embedded = Embedded || require('./types/ArraySubdocument');\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function (seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function (seed, path) {\n        return docReducer(val._doc, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n\n        seed = Object.keys(doc._doc).reduce(function (seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n\n    return seed;\n  }\n\n  const subDocs = [];\n\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n\n  return subDocs;\n};\n/*!\n * Runs queued functions\n */\n\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.$listeners('error').length) {\n    this.$emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$toObject = function (options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = get(this, 'constructor.base.options.' + path, {});\n  const schemaOptions = get(this, '$__schema.options', {}); // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {})); // If options do not exist or is not an object, set it to empty object\n\n  options = utils.isPOJO(options) ? clone(options) : {};\n  options._calledWithOptions = options._calledWithOptions || clone(options);\n\n  let _minimize;\n\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  let flattenMaps;\n\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  } // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n\n\n  const cloneOptions = Object.assign(utils.clone(options), {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate || get(options, '_parentOptions.depopulate', false); // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, cloneOptions);\n  } // merge default options with input options.\n\n\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = true;\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = false; // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n\n  const originalTransform = options.transform;\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n\n  let transform = options.transform; // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || schemaOptions.toObject && transform) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = typeof options.transform === 'function' ? options.transform : opts.transform;\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters), defaults to false\n * - `aliases` apply all aliases if `virtuals=true`, defaults to true\n * - `virtuals` apply virtual getters (can override `getters` option), defaults to false\n * - `minimize` remove empty objects, defaults to true\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs, defaults to false\n * - `versionKey` whether to include the version key, defaults to true\n * - `flattenMaps` convert Maps to POJOs. Useful if you want to JSON.stringify() the result of toObject(), defaults to false\n * - `useProjection` set to `true` to omit fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this is behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toObject = function (options) {\n  return this.$toObject(options);\n};\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys ? obj : undefined;\n}\n/*!\n * Applies virtuals properties to `json`.\n */\n\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = get(toObjectOptions, 'aliases', true);\n  let virtualsToApply = null;\n\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  } else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    } // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n\n\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    } // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n\n\n    assignPath = path;\n\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n\n      assignPath = path.substr(options.path.length + 1);\n    }\n\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n\n    if (v === void 0) {\n      continue;\n    }\n\n    const plen = parts.length;\n    cur = json;\n\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n\n      if (ii === last) {\n        const val = self.$get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n\n      cur = v;\n    }\n  }\n\n  return json;\n}\n/*!\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.$get(path);\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null && typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const vals = [].concat(self.$get(path));\n      const transform = schematype.$embeddedSchemaType.options.transform;\n\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toJSON = function (options) {\n  return this.$toObject(options, true);\n};\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.parent = function () {\n  return this.$__.parent;\n};\n/**\n * Alias for `parent()`. If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$parent = Document.prototype.parent;\n/**\n * Helper for console.log\n *\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function (options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toString = function () {\n  const ret = this.inspect();\n\n  if (typeof ret === 'string') {\n    return ret;\n  }\n\n  return inspect(ret);\n};\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.equals = function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n\n  return tid && tid.equals ? tid.equals(docid) : tid === docid;\n};\n/**\n * Populates paths on an existing document.\n *\n * ####Example:\n *\n *     await doc.populate([\n *       'stories',\n *       { path: 'fans', sort: { name: -1 } }\n *     ]);\n *     doc.populated('stories'); // Array of ObjectIds\n *     doc.stories[0].title; // 'Casino Royale'\n *     doc.populated('fans'); // Array of ObjectIds\n *\n *     await doc.populate('fans', '-email');\n *     doc.fans[0].email // not populated\n *\n *     await doc.populate('author fans', '-email');\n *     doc.author.email // not populated\n *     doc.fans[0].email // not populated\n *\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://docs.mongodb.com/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [callback] Callback\n * @see population ./populate.html\n * @see Query#select #query_Query-select\n * @see Model.populate #model_Model.populate\n * @memberOf Document\n * @instance\n * @return {Promise|null}\n * @api public\n */\n\n\nDocument.prototype.populate = function populate() {\n  const pop = {};\n  const args = utils.args(arguments);\n  let fn;\n\n  if (args.length > 0) {\n    if (typeof args[args.length - 1] === 'function') {\n      fn = args.pop();\n    } // use hash to remove duplicate paths\n\n\n    const res = utils.populate.apply(null, args);\n\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  const paths = utils.object.vals(pop);\n  let topLevelModel = this.constructor;\n\n  if (this.$__isNested) {\n    topLevelModel = this.$__[scopeSymbol].constructor;\n    const nestedPath = this.$__.nestedPath;\n    paths.forEach(function (populateOptions) {\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\n    });\n  } // Use `$session()` by default if the document has an associated session\n  // See gh-6754\n\n\n  if (this.$session() != null) {\n    const session = this.$session();\n    paths.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  paths.forEach(p => {\n    p._localModel = topLevelModel;\n  });\n  return topLevelModel.populate(this, paths, fn);\n};\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Array<Document>} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n\n  let result = [];\n\n  for (const key of keys) {\n    const value = this.$get(key);\n\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n\n  return result;\n};\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.populated = function (path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n\n    if (typeof path !== 'string') {\n      return undefined;\n    } // Map paths can be populated with either `path.$*` or just `path`\n\n\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n\n    const v = this.$__.populated[_path];\n\n    if (v) {\n      return val === true ? v : v.value;\n    }\n\n    return undefined;\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {\n    value: val,\n    options: options\n  }; // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n\n  const pieces = path.split('.');\n\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.$get(subpath);\n\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.$populated(rest, val, options); // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n\n      break;\n    }\n  }\n\n  return val;\n};\n\nDocument.prototype.$populated = Document.prototype.populated;\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function (path) {\n  if (typeof path === 'string') {\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = get(this, '$__.populated', {});\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.$populated(key);\n\n      if (!populatedIds) {\n        continue;\n      }\n\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.$populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n\n  return this;\n};\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__fullPath = function (path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.getChanges = function () {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n/*!\n * Module exports.\n */\n\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;","map":{"version":3,"sources":["/home/gregorian/calendar-ui/node_modules/mongoose/lib/document.js"],"names":["EventEmitter","require","InternalCache","MongooseError","MixedSchema","ObjectExpectedError","ObjectParameterError","ParallelValidateError","Schema","StrictModeError","ValidationError","ValidatorError","VirtualType","promiseOrCallback","cleanModifiedSubpaths","compile","defineKey","flatten","flattenObjectWithDottedPaths","get","getEmbeddedDiscriminatorPath","getKeysInSchemaOrder","handleSpreadDoc","immediate","isDefiningProjection","isExclusive","inspect","internalToObjectOptions","markArraySubdocsPopulated","mpath","queryhelpers","utils","isPromise","clone","deepEqual","isMongooseObject","arrayAtomicsBackupSymbol","arrayAtomicsSymbol","documentArrayParent","documentIsModified","documentModifiedPaths","documentSchemaSymbol","getSymbol","populateModelSymbol","scopeSymbol","schemaMixedSymbol","parentPaths","DocumentArray","MongooseArray","Embedded","specialProperties","Document","obj","fields","skipId","options","Object","assign","$__schema","_schema","isObject","instanceOfSchema","$__setSchema","arguments","$__","emitter","$isNew","isNew","priorDoc","defaults","undefined","schema","strictMode","strict","selected","requiredPaths","path","activePaths","setMaxListeners","exclude","isPOJO","hasIncludedChildren","$__hasIncludedChildren","_doc","$__buildDoc","$__applyDefaults","$__original_set","$set","willInit","prototype","once","call","skipDefaults","_id","_this","keys","forEach","key","tree","prop","subprops","applyQueue","defineProperty","set","value","$errors","each","emitterFn","apply","constructor","i","configurable","enumerable","locals","v","writable","id","errors","op","parts","split","c","part","push","join","doc","isBeforeSetters","pathsToSkip","paths","plen","length","def","curPath","p","type","splitPath","len","included","doc_","j","piece","defaultValue","$runBeforeSetters","getDefault","err","invalidate","default","$applyDefaultsToNested","val","pathPieces","indexOf","startsWith","pieces","slice","cur","filter","includes","ii","last","toBSON","toObject","init","opts","fn","$__init","$init","populated","String","item","isVirtual","$populated","getValue","_docs","_childDocs","child","parent","$emit","emit","self","prefix","index","_init","$isRootDiscriminator","$__isSelected","hasOwnProperty","_castNullish","intCache","wasPopulated","cast","e","message","reason","$isModified","update","args","unshift","query","$session","session","updateOne","callback","pre","cb","_middleware","execPre","post","execPost","exec","replaceOne","hasEnded","ownerDocument","subdocs","$getAllSubdocs","overwrite","Array","from","Set","concat","versionKey","discriminatorKey","merge","adhoc","constructing","typeKey","adhocs","pathtype","adhocPaths","interpretAsType","$__isNested","_skipMinimizeTopLevel","pathName","pathType","valForKey","isNonBuiltinObject","_skipMarkModified","$get","typeOnly","$isSingleNested","virtuals","transform","priorVal","$__getValue","hasInitialVal","savedState","initialVal","$__setValue","unmarkModified","markModified","skipDocArrays","CastError","aliases","mixed","subpath","virtualpath","applySetters","$__path","pathToMark","getters","$__set","$isMongooseArray","_markValidSubpaths","shouldSet","refMatches","model","ref","modelName","baseModelName","refPath","didPopulate","popOpts","isArray","_isManuallyPopulatedArray","map","singleNestedPaths","$isMongooseDocumentArray","populatedPaths","populatedPath","_checkImmutableSubpaths","$markValid","isImmutableError","$originalErrorPath","instance","savedStatePath","fullPath","firstDot","topLevelPath","isDirectModified","el","$__shouldModify","states","shouldModify","isMongooseArray","_registerAtomic","isMongooseDocumentArray","__parentArray","modifiedPath","ignore","l","next","has","Map","setValue","virtual","applyGetters","nested","applyVirtuals","adhocType","scope","modify","pathsToScopes","$__pathsToScopes","$ignore","directModifiedPaths","$isEmpty","isEmptyOptions","minimize","_isEmpty","modifiedPaths","reduce","list","chains","chain","includeChildren","modified","childPath","isModified","isModifiedChild","some","mod","$isDefault","$isDeleted","isDeleted","isInit","isSelected","inclusive","pathDot","isDirectSelected","validate","pathsToValidate","parallelValidate","$op","validating","parentStack","conflictStack","stack","isOnePathOnly","$__validate","error","events","$validate","_evaluateRequiredFunctions","originalRequiredValue","cachedRequired","_getPathsToValidate","skipSchemaValidators","addToPaths","add","subdoc","$basePath","delete","_pathType","_pushNestedArrayPaths","numElements","flattenOptions","skipArrays","pathToCheck","_v","flat","$isSchemaMap","hasValidateModifiedOnlyOption","shouldValidateModifiedOnly","validateModifiedOnly","_complete","validationError","errPath","pathDetails","_handlePathsToValidate","_handlePathsToSkip","s","hooks","validated","total","validatePath","schemaType","complete","$isValid","pop","doValidateOptions","doValidate","isSubdoc","$isArraySubdocument","_pathsToValidate","ret","validateSync","doValidateSync","kind","addError","schematype","$immutableSetter","oldVal","$__reset","reset","array","$path","$parent","$__dirty","dirt","backup","clear","$__undoReset","all","allPaths","minimal","top","hasAtomics","_applyDefaultGetters","$__getArrayPathsToValidate","bind","seed","docReducer","isNested","_docReduce","subDocs","q","callQueue","pair","$__handleReject","handleReject","$listeners","listeners","$toObject","json","defaultOptions","flattenDecimals","baseOptions","schemaOptions","_calledWithOptions","_minimize","flattenMaps","cloneOptions","_isNested","hasUserDefinedProperty","depopulate","_parentOptions","_skipSingleNestedGetters","gettersOptions","originalTransform","applySchemaTypeTransforms","useProjection","omitDeselectedFields","toJSON","xformed","hasKeys","toObjectOptions","numPaths","assignPath","virtualsToApply","substr","branch","transformedValue","throwErrorIfPromise","$embeddedSchemaType","vals","Error","applyPaths","custom","toString","equals","tid","docid","populate","res","populateOptions","object","topLevelModel","nestedPath","_localModel","$getPopulatedDocs","result","_path","endsWith","replace","rest","populatedIds","virtualKeys","$$populatedVirtuals","virtualKey","singlePath","$__fullPath","getChanges","delta","$__delta","changes","module","exports"],"mappings":"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AA0CxL,OAAO,CAACwL,SAAlD,GAA8D7E,IAAI,CAAC6E,SAAhF;AACD;AACF,GAND,MAMO;AACLxL,IAAAA,OAAO,CAACwL,SAAR,GAAoB+M,iBAApB;AACD;;AAED,MAAI,OAAO/M,SAAP,KAAqB,UAAzB,EAAqC;AACnC,UAAMoN,OAAO,GAAGpN,SAAS,CAAC,IAAD,EAAOyJ,GAAP,EAAYjV,OAAZ,CAAzB;;AACA,QAAI,OAAO4Y,OAAP,KAAmB,WAAvB,EAAoC;AAClC3D,MAAAA,GAAG,GAAG2D,OAAN;AACD;AACF;;AAED,SAAO3D,GAAP;AACD,CAlID;AAoIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEArV,QAAQ,CAACsC,SAAT,CAAmBuE,QAAnB,GAA8B,UAASzG,OAAT,EAAkB;AAC9C,SAAO,KAAKuX,SAAL,CAAevX,OAAf,CAAP;AACD,CAFD;AAIA;AA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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst InternalCache = require('./internal');\nconst MongooseError = require('./error/index');\nconst MixedSchema = require('./schema/mixed');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst ObjectParameterError = require('./error/objectParameter');\nconst ParallelValidateError = require('./error/parallelValidate');\nconst Schema = require('./schema');\nconst StrictModeError = require('./error/strict');\nconst ValidationError = require('./error/validation');\nconst ValidatorError = require('./error/validator');\nconst VirtualType = require('./virtualtype');\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\nconst compile = require('./helpers/document/compile').compile;\nconst defineKey = require('./helpers/document/compile').defineKey;\nconst flatten = require('./helpers/common').flatten;\nconst flattenObjectWithDottedPaths = require('./helpers/path/flattenObjectWithDottedPaths');\nconst get = require('./helpers/get');\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\nconst getKeysInSchemaOrder = require('./helpers/schema/getKeysInSchemaOrder');\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\nconst immediate = require('./helpers/immediate');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst isExclusive = require('./helpers/projection/isExclusive');\nconst inspect = require('util').inspect;\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst markArraySubdocsPopulated = require('./helpers/populate/markArraySubdocsPopulated');\nconst mpath = require('mpath');\nconst queryhelpers = require('./queryhelpers');\nconst utils = require('./utils');\nconst isPromise = require('./helpers/isPromise');\n\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = require('./helpers/symbols').arrayAtomicsBackupSymbol;\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\nconst getSymbol = require('./helpers/symbols').getSymbol;\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\nconst schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;\nconst parentPaths = require('./helpers/path/parentPaths');\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n\n  // Support `browserDocument.js` syntax\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\n      new Schema(fields) :\n      fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache;\n  this.$__.emitter = new EventEmitter();\n  this.$isNew = 'isNew' in options ? options.isNew : true;\n\n  if ('priorDoc' in options) {\n    this.$__.priorDoc = options.priorDoc;\n  }\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  let defaults = true;\n  if (options.defaults !== undefined) {\n    this.$__.defaults = options.defaults;\n    defaults = options.defaults;\n  }\n\n  const schema = this.$__schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options.strict;\n    if (fields !== undefined) {\n      this.$__.selected = fields;\n    }\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields)) {\n    exclude = isExclusive(fields);\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    {};\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {\n        isNew: this.$isNew\n      });\n    }\n  }\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true);\n    } else {\n      this.$set(obj, undefined, true);\n    }\n\n    if (obj instanceof Document) {\n      this.$isNew = obj.$isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    EventEmitter.prototype.once.call(this, 'init', () => {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n        isNew: this.$isNew\n      });\n    });\n  } else if (defaults) {\n    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n      isNew: this.$isNew\n    });\n  }\n\n  this.$__._id = this._id;\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      if (!(key in schema.tree)) {\n        defineKey({ prop: key, subprops: null, prototype: _this });\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\nObject.defineProperty(Document.prototype, 'isNew', {\n  get: function() {\n    return this.$isNew;\n  },\n  set: function(value) {\n    this.$isNew = value;\n  }\n});\n\nObject.defineProperty(Document.prototype, 'errors', {\n  get: function() {\n    return this.$errors;\n  },\n  set: function(value) {\n    this.$errors = value;\n  }\n});\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\n  });\n\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__schema;\n\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * ####Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    if (this.$__.locals == null) {\n      this.$__.locals = {};\n    }\n    return this.$__.locals;\n  },\n  set: function(v) {\n    this.$__.locals = v;\n  }\n});\n\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property $isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$isNew;\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * ####Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation $errors.\n *\n * @api public\n * @property $errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$errors;\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.errors;\n\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * ####Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$op', {\n  get: function() {\n    return this.$__.op || null;\n  },\n  set: function(value) {\n    this.$__.op = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nfunction $__hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n\n  for (const key of keys) {\n    const parts = key.split('.');\n    const c = [];\n\n    for (const part of parts) {\n      c.push(part);\n      hasIncludedChildren[c.join('.')] = 1;\n    }\n  }\n\n  return hasIncludedChildren;\n}\n\n/*!\n * ignore\n */\n\nfunction $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && skipId) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (typeof type.defaultValue === 'function') {\n          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n            break;\n          }\n          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n            break;\n          }\n        } else if (!isBeforeSetters) {\n          // Non-function defaults should always run **before** setters\n          continue;\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            doc.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction $applyDefaultsToNested(val, path, doc) {\n  if (val == null) {\n    return;\n  }\n\n  flattenObjectWithDottedPaths(val);\n\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    if (!p.startsWith(path + '.')) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const pieces = type.splitPath().slice(pathPieces.length);\n    const len = pieces.length;\n\n    if (type.defaultValue === void 0) {\n      continue;\n    }\n\n    let cur = val;\n\n    for (let j = 0; j < len; ++j) {\n      if (cur == null) {\n        break;\n      }\n\n      const piece = pieces[j];\n\n      if (j === len - 1) {\n        if (cur[piece] !== void 0) {\n          break;\n        }\n\n        try {\n          const def = type.getDefault(doc, false);\n          if (def !== void 0) {\n            cur[piece] = def;\n          }\n        } catch (err) {\n          doc.invalidate(path + '.' + curPath, err);\n          break;\n        }\n\n        break;\n      }\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      cur[piece] = cur[piece] || {};\n      cur = cur[piece];\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.$__schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\nDocument.prototype.$init = function() {\n  return this.constructor.prototype.init.apply(this, arguments);\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.$isNew = false;\n  this.$init = true;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.$populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n      item._childDocs = [];\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n\n  markArraySubdocsPopulated(this, opts.populated);\n\n  this.$emit('init', this);\n  this.constructor.emit('init', this);\n\n  this.$__._id = this._id;\n  return this;\n};\n\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schema;\n  let path;\n  let i;\n  let index = 0;\n  const strict = self.$__.strictMode;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.$__schema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (self.$__schema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    if (!schema && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schema) {\n      doc[i] = obj[i];\n      if (!strict) {\n        self[i] = obj[i];\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\n        delete doc[i];\n      }\n      if (obj[i] === null) {\n        doc[i] = schema._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const intCache = obj[i].$__ || {};\n        const wasPopulated = intCache.wasPopulated || null;\n\n        if (schema && !wasPopulated) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.update = function update() {\n  const args = utils.args(arguments);\n  args.unshift({ _id: this._id });\n  const query = this.constructor.update.apply(this.constructor, args);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  return query;\n};\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model.updateOne)\n *\n * @see Model.updateOne #model_Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({ _id: this._id }, doc, options);\n  query.pre(cb => {\n    this.constructor._middleware.execPre('updateOne', this, [this], cb);\n  });\n  query.post(cb => {\n    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * ####Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model.replaceOne)\n *\n * @see Model.replaceOne #model_Model.replaceOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = utils.args(arguments);\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * ####Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n    return this.$__.session;\n  }\n\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' +\n      'called `endSession()` on the session you are passing to `$session()`.');\n  }\n\n  this.$__.session = session;\n\n  if (!this.ownerDocument) {\n    const subdocs = this.$getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @name overwrite\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @method $set\n * @name $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  options = options || {};\n  const merge = options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  const typeKey = this.$__schema.options.typeKey;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const strict = 'strict' in options\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  if (path == null) {\n    [path, val] = [val, path];\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n    if (path == null) {\n      [path, val] = [val, path];\n    }\n\n    prefix = val ? val + '.' : '';\n    keys = getKeysInSchemaOrder(this.$__schema, path);\n\n    const len = keys.length;\n\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n      if (val) {\n        this.$set(val, {});\n      }\n      return this;\n    }\n\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix + key;\n      pathtype = this.$__schema.pathType(pathName);\n      const valForKey = path[key];\n\n      // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n      if (type === true &&\n          !prefix &&\n          path[key] != null &&\n          pathtype === 'nested' &&\n          this._doc[key] != null) {\n        delete this._doc[key];\n        // Make sure we set `{}` back even if we minimize re: gh-8565\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });\n      } else {\n        // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: false });\n      }\n\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\n        $applyDefaultsToNested(path[key], prefix + key, this);\n        this.$set(prefix + key, path[key], constructing, Object.assign({}, options, { _skipMarkModified: true }));\n        continue;\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && path[key] === void 0 &&\n            this.$get(pathName) !== void 0) {\n          continue;\n        }\n\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n        }\n\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          // Check for setting single embedded schema to document (gh-3535)\n          let p = path[key];\n          if (this.$__schema.paths[pathName] &&\n              this.$__schema.paths[pathName].$isSingleNested &&\n              path[key] instanceof Document) {\n            p = p.toObject({ virtuals: false, transform: false });\n          }\n          this.$set(prefix + key, p, constructing, options);\n        } else if (pathtype === 'nested' && path[key] instanceof Document) {\n          this.$set(prefix + key,\n            path[key].toObject({ transform: false }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, path[key]);\n          } else {\n            throw new StrictModeError(key);\n          }\n        }\n      } else if (path[key] !== void 0) {\n        this.$set(prefix + key, path[key], constructing, options);\n      }\n    }\n\n    // Ensure all properties are in correct order by deleting and recreating every property.\n    for (const key of Object.keys(this.$__schema.tree)) {\n      if (this._doc.hasOwnProperty(key)) {\n        const val = this._doc[key];\n        delete this._doc[key];\n        this._doc[key] = val;\n      }\n    }\n\n    return this;\n  }\n\n  let pathType = this.$__schema.pathType(path);\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val);\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.priorDoc != null) {\n      return this.$__.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const initialVal = this.$__getValue(path);\n        this.$__.savedState[path] = initialVal;\n\n        const keys = Object.keys(initialVal || {});\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = initialVal[key];\n        }\n      }\n\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\n\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing, options);\n      }\n      if (priorVal != null && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n      cleanModifiedSubpaths(this, path, { skipDocArrays: true });\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[parts[0]] == 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.$__schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length > 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.$get(subpath, null, { getters: false }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  if (!schema) {\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (schema.$isSingleNested && val != null && merge) {\n    if (val instanceof Document) {\n      val = val.toObject({ virtuals: false, transform: false });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document) {\n      this.$populated(path, val._id, { [populateModelSymbol]: val.constructor });\n      val.$__.wasPopulated = true;\n      didPopulate = true;\n    }\n\n    let popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options[typeKey]) &&\n        schema.options[typeKey].length &&\n        schema.options[typeKey][0].ref &&\n        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = { [populateModelSymbol]: val[0].constructor };\n      this.$populated(path, val.map(function(v) { return v._id; }), popOpts);\n\n      for (const doc of val) {\n        doc.$__.wasPopulated = true;\n      }\n      didPopulate = true;\n    }\n\n    if (this.$__schema.singleNestedPaths[path] == null) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      val = schema.applySetters(val, this, false, priorVal);\n    }\n\n    if (schema.$isMongooseDocumentArray &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] != null &&\n        val[0].$__ != null &&\n        val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.$populated(path + '.' + populatedPath,\n          val.map(v => v.$populated(populatedPath)),\n          val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val.set(i, val[i]._id, true);\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n\n    if (schema.$isSingleNested && val != null) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path,\n          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path,\n        new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    const doc = this.ownerDocument ? this.ownerDocument() : this;\n    const savedState = doc.$__.savedState;\n    const savedStatePath = this.ownerDocument ? this.$__.fullPath + '.' + path : path;\n    if (savedState != null) {\n      const firstDot = savedStatePath.indexOf('.');\n      const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\n      if (!savedState.hasOwnProperty(topLevelPath)) {\n        savedState[topLevelPath] = utils.clone(doc.$__getValue(topLevelPath));\n      }\n    }\n\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (savedState != null && savedState.hasOwnProperty(savedStatePath) && utils.deepEqual(val, savedState[savedStatePath])) {\n      this.unmarkModified(path);\n    }\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  if (options._skipMarkModified) {\n    return false;\n  }\n  if (this.$isNew) {\n    return true;\n  }\n\n  // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n  if (this.$__schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.$populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/ArraySubdocument');\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts,\n    schema, val, priorVal);\n  const _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.startsWith(path + '.')) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  } else if (Array.isArray(val) && val.isMongooseArray && Array.isArray(priorVal) && priorVal.isMongooseArray) {\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\nDocument.prototype.$__getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\nDocument.prototype.$__setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  options = options || {};\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  let schema = this.$__path(path);\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n  }\n  if (schema instanceof MixedSchema) {\n    const virtual = this.$__schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n  const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let obj = this._doc;\n\n  if (schema instanceof VirtualType) {\n    return schema.applyGetters(void 0, this);\n  }\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[pieces[0]] == 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], { getters: false });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });\n  }\n\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\nDocument.prototype.$get = Document.prototype.get;\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.$__schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.ownerDocument) {\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  if (this.$__.pathsToScopes != null) {\n    delete this.$__.pathsToScopes[path];\n  }\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * ####Example\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function() {\n  return Object.keys(this.$__.activePaths.states.modify);\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * ####Example:\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function(path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length > 0) {\n    const v = this.$get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  const _this = this;\n  return directModifiedPaths.reduce(function(list, path) {\n    const parts = path.split('.');\n    list = list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n\n    if (!options.includeChildren) {\n      return list;\n    }\n\n    let cur = _this.$get(path);\n    if (cur != null && typeof cur === 'object') {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      if (Array.isArray(cur)) {\n        const len = cur.length;\n        for (let i = 0; i < len; ++i) {\n          if (list.indexOf(path + '.' + i) === -1) {\n            list.push(path + '.' + i);\n            if (cur[i] != null && cur[i].$__) {\n              const modified = cur[i].modifiedPaths();\n              for (const childPath of modified) {\n                list.push(path + '.' + i + '.' + childPath);\n              }\n            }\n          }\n        }\n      } else {\n        Object.keys(cur).\n          filter(function(key) {\n            return list.indexOf(path + '.' + key) === -1;\n          }).\n          forEach(function(key) {\n            list.push(path + '.' + key);\n          });\n      }\n    }\n\n    return list;\n  }, []);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, modifiedPaths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\nDocument.prototype.$isModified = Document.prototype.isModified;\n\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.default.hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.default.hasOwnProperty(path));\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * ####Example:\n *     const product = await product.remove();\n *     product.$isDeleted(); // true\n *     product.remove(); // no-op, doesn't send anything to the db\n *\n *     product.$isDeleted(false);\n *     product.$isDeleted(); // false\n *     product.remove(); // will execute a remove against the db\n *\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.modify.hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.modify.hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.init.hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.init.hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     const doc = await Thing.findOne().select('name');\n *     doc.isSelected('name') // true\n *     doc.isSelected('age')  // false\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n\n  const pathDot = path + '.';\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n\n  return !inclusive;\n};\n\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * ####Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n\n  return !inclusive;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\nDocument.prototype.validate = function(pathsToValidate, options, callback) {\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.ownerDocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });\n  }\n\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      callback = null;\n      pathsToValidate = null;\n    } else if (typeof arguments[0] === 'function') {\n      callback = arguments[0];\n      options = null;\n      pathsToValidate = null;\n    }\n  } else if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = pathsToValidate;\n    pathsToValidate = null;\n  }\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n\n  return promiseOrCallback(callback, cb => {\n    if (parallelValidate != null) {\n      return cb(parallelValidate);\n    }\n\n    this.$__validate(pathsToValidate, options, (error) => {\n      this.$op = null;\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n\nDocument.prototype.$validate = Document.prototype.validate;\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  Object.keys(doc.$__.activePaths.states.require).forEach(path => {\n    const p = doc.$__schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\n      doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n    }\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc) {\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc);\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function(path) {\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\n      return false;\n    }\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n\n\n  Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);\n  function addToPaths(p) { paths.add(p); }\n\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc\n      for (const p of paths) {\n        if (p === null || p.startsWith(subdoc.$basePath + '.')) {\n          paths.delete(p);\n        }\n      }\n\n      if (doc.$isModified(subdoc.$basePath, modifiedPaths) &&\n            !doc.isDirectModified(subdoc.$basePath) &&\n            !doc.$isDefault(subdoc.$basePath)) {\n        paths.add(subdoc.$basePath);\n\n        skipSchemaValidators[subdoc.$basePath] = true;\n      }\n    }\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType ||\n        !_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (_pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required'))) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = { skipArrays: true };\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, skipSchemaValidators];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  const pathsToSkip = get(options, 'pathsToSkip', null);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = undefined;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.$isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.$emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    this.$__.validating = null;\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] &&\n            validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (pathsToSkip) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n  if (paths.length === 0) {\n    return immediate(function() {\n      const error = _complete();\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  for (const path of paths) {\n    validatePath(path);\n  }\n\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    immediate(function() {\n      const schemaType = _this.$__schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if ((pop = _this.$populated(path))) {\n        val = pop;\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\n        // so in that case pull out the document's id\n        val = val._id;\n      }\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      const doValidateOptions = {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n\n      schemaType.doValidate(val, function(err) {\n        if (err) {\n          const isSubdoc = schemaType.$isSingleNested ||\n            schemaType.$isArraySubdocument ||\n            schemaType.$isMongooseDocumentArray;\n          if (isSubdoc && err instanceof ValidationError) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n\n  function complete() {\n    const error = _complete();\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  }\n\n};\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = [];\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.push(path);\n    } else if (parentPaths.has(path)) {\n      ret.push(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/*!\n * ignore\n */\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = paths.filter(p => !pathsToSkip.has(p));\n  return paths;\n}\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate, options) {\n  const _this = this;\n\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  let pathsToSkip = options && options.pathsToSkip;\n\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n  const validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    const p = _this.$__schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n    if (err) {\n      const isSubdoc = p.$isSingleNested ||\n        p.$isArraySubdocument ||\n        p.$isMongooseDocumentArray;\n      if (isSubdoc && err instanceof ValidationError) {\n        return;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.$emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](/docs/api.html#document_Document-isNew) is `true`,\n * or sends an [updateOne](/docs/api.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * ####Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](api.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|Array<String>} path the field to check\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n  if (path == null) {\n    return false;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n\n  return this.$__.validationError.errors[path] == null;\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n\n  this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return _this.$__getValue(i);\n    })\n    .filter(function(val) {\n      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n    })\n    .forEach(function(array) {\n      let i = array.length;\n      while (i--) {\n        const doc = array[i];\n        if (!doc) {\n          continue;\n        }\n        doc.$__reset();\n      }\n\n      _this.$__.activePaths.init(array.$path());\n\n      array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n      array[arrayAtomicsSymbol] = {};\n    });\n\n  this.$__.activePaths.\n    map('init', 'modify', function(i) {\n      return _this.$__getValue(i);\n    }).\n    filter(function(val) {\n      return val && val.$isSingleNested;\n    }).\n    forEach(function(doc) {\n      doc.$__reset();\n      if (doc.$parent() === _this) {\n        _this.$__.activePaths.init(doc.$basePath);\n      } else if (doc.$parent() != null && doc.$parent().ownerDocument) {\n        // If map path underneath subdocument, may end up with a case where\n        // map path is modified but parent still needs to be reset. See gh-10295\n        doc.$parent().$__reset();\n      }\n    });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.states.modify),\n    default: Object.assign({}, this.$__.activePaths.states.default)\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.$errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.$errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n\n  this.$__.validationError = this.$__.backup.validationError;\n  this.$errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n\n    let top = null;\n\n    const array = parentPaths(item.path);\n    for (let i = 0; i < array.length - 1; i++) {\n      if (allPaths.has(array[i])) {\n        top = allPaths.get(array[i]);\n        break;\n      }\n    }\n    if (top == null) {\n      minimal.push(item);\n    } else if (top != null &&\n        top[arrayAtomicsSymbol] != null &&\n        top.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being set.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top[arrayAtomicsSymbol] = {};\n      top[arrayAtomicsSymbol].$set = top;\n    }\n  });\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.$__getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n  Embedded = Embedded || require('./types/ArraySubdocument');\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val._doc, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n    return seed;\n  }\n\n  const subDocs = [];\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.$listeners('error').length) {\n    this.$emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = get(this, 'constructor.base.options.' + path, {});\n  const schemaOptions = get(this, '$__schema.options', {});\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? clone(options) : {};\n  options._calledWithOptions = options._calledWithOptions || clone(options);\n\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  let flattenMaps;\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign(utils.clone(options), {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate ||\n    get(options, '_parentOptions.depopulate', false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = true;\n\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = false;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters), defaults to false\n * - `aliases` apply all aliases if `virtuals=true`, defaults to true\n * - `virtuals` apply virtual getters (can override `getters` option), defaults to false\n * - `minimize` remove empty objects, defaults to true\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs, defaults to false\n * - `versionKey` whether to include the version key, defaults to true\n * - `flattenMaps` convert Maps to POJOs. Useful if you want to JSON.stringify() the result of toObject(), defaults to false\n * - `useProjection` set to `true` to omit fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this is behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = get(toObjectOptions, 'aliases', true);\n\n  let virtualsToApply = null;\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  }\n  else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    }\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substr(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n\n\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        const val = self.$get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/*!\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.$get(path);\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null &&\n        typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const vals = [].concat(self.$get(path));\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.parent = function() {\n  return this.$__.parent;\n};\n\n/**\n * Alias for `parent()`. If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$parent = Document.prototype.parent;\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates paths on an existing document.\n *\n * ####Example:\n *\n *     await doc.populate([\n *       'stories',\n *       { path: 'fans', sort: { name: -1 } }\n *     ]);\n *     doc.populated('stories'); // Array of ObjectIds\n *     doc.stories[0].title; // 'Casino Royale'\n *     doc.populated('fans'); // Array of ObjectIds\n *\n *     await doc.populate('fans', '-email');\n *     doc.fans[0].email // not populated\n *\n *     await doc.populate('author fans', '-email');\n *     doc.author.email // not populated\n *     doc.fans[0].email // not populated\n *\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://docs.mongodb.com/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [callback] Callback\n * @see population ./populate.html\n * @see Query#select #query_Query-select\n * @see Model.populate #model_Model.populate\n * @memberOf Document\n * @instance\n * @return {Promise|null}\n * @api public\n */\n\nDocument.prototype.populate = function populate() {\n  const pop = {};\n  const args = utils.args(arguments);\n  let fn;\n\n  if (args.length > 0) {\n    if (typeof args[args.length - 1] === 'function') {\n      fn = args.pop();\n    }\n\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  const paths = utils.object.vals(pop);\n  let topLevelModel = this.constructor;\n  if (this.$__isNested) {\n    topLevelModel = this.$__[scopeSymbol].constructor;\n    const nestedPath = this.$__.nestedPath;\n    paths.forEach(function(populateOptions) {\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\n    });\n  }\n\n  // Use `$session()` by default if the document has an associated session\n  // See gh-6754\n  if (this.$session() != null) {\n    const session = this.$session();\n    paths.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  paths.forEach(p => {\n    p._localModel = topLevelModel;\n  });\n\n  return topLevelModel.populate(this, paths, fn);\n};\n\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Array<Document>} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @instance\n */\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n  let result = [];\n  for (const key of keys) {\n    const value = this.$get(key);\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    if (typeof path !== 'string') {\n      return undefined;\n    }\n\n    // Map paths can be populated with either `path.$*` or just `path`\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n\n    const v = this.$__.populated[_path];\n    if (v) {\n      return val === true ? v : v.value;\n    }\n    return undefined;\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.$get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.$populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n\n  return val;\n};\n\nDocument.prototype.$populated = Document.prototype.populated;\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = get(this, '$__.populated', {});\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.$populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.$populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.getChanges = function() {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n"]},"metadata":{},"sourceType":"script"}