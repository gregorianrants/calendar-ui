{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst ArrayMethods = require('../array/methods');\n\nconst DocumentArrayMethods = require('./methods');\n\nconst Document = require('../../document');\n\nconst arrayAtomicsSymbol = require('../../helpers/symbols').arrayAtomicsSymbol;\n\nconst arrayAtomicsBackupSymbol = require('../../helpers/symbols').arrayAtomicsBackupSymbol;\n\nconst arrayParentSymbol = require('../../helpers/symbols').arrayParentSymbol;\n\nconst arrayPathSymbol = require('../../helpers/symbols').arrayPathSymbol;\n\nconst arraySchemaSymbol = require('../../helpers/symbols').arraySchemaSymbol;\n\nconst _basePush = Array.prototype.push;\n/**\n * DocumentArray constructor\n *\n * @param {Array} values\n * @param {String} path the path to this array\n * @param {Document} doc parent document\n * @api private\n * @return {MongooseDocumentArray}\n * @inherits MongooseArray\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseDocumentArray(values, path, doc) {\n  const arr = [];\n  const internals = {\n    [arrayAtomicsSymbol]: {},\n    [arrayAtomicsBackupSymbol]: void 0,\n    [arrayPathSymbol]: path,\n    [arraySchemaSymbol]: void 0,\n    [arrayParentSymbol]: void 0\n  };\n\n  if (Array.isArray(values)) {\n    if (values[arrayPathSymbol] === path && values[arrayParentSymbol] === doc) {\n      internals[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);\n    }\n\n    values.forEach(v => {\n      _basePush.call(arr, v);\n    });\n  }\n\n  internals[arrayPathSymbol] = path; // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020 && #3034)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n\n  if (doc && doc instanceof Document) {\n    internals[arrayParentSymbol] = doc;\n    internals[arraySchemaSymbol] = doc.schema.path(path); // `schema.path()` doesn't drill into nested arrays properly yet, see\n    // gh-6398, gh-6602. This is a workaround because nested arrays are\n    // always plain non-document arrays, so once you get to a document array\n    // nesting is done. Matryoshka code.\n\n    while (internals[arraySchemaSymbol] != null && internals[arraySchemaSymbol].$isMongooseArray && !internals[arraySchemaSymbol].$isMongooseDocumentArray) {\n      internals[arraySchemaSymbol] = internals[arraySchemaSymbol].casterConstructor;\n    }\n  }\n\n  const proxy = new Proxy(arr, {\n    get: function (target, prop) {\n      if (prop === 'isMongooseArray' || prop === 'isMongooseArrayProxy' || prop === 'isMongooseDocumentArray' || prop === 'isMongooseDocumentArrayProxy') {\n        return true;\n      }\n\n      if (prop === '__array') {\n        return arr;\n      }\n\n      if (prop === 'set') {\n        return set;\n      }\n\n      if (internals.hasOwnProperty(prop)) {\n        return internals[prop];\n      }\n\n      if (DocumentArrayMethods.hasOwnProperty(prop)) {\n        return DocumentArrayMethods[prop];\n      }\n\n      if (ArrayMethods.hasOwnProperty(prop)) {\n        return ArrayMethods[prop];\n      }\n\n      return arr[prop];\n    },\n    set: function (target, prop, value) {\n      if (typeof prop === 'string' && /^\\d+$/.test(prop)) {\n        set.call(proxy, prop, value);\n      } else if (internals.hasOwnProperty(prop)) {\n        internals[prop] = value;\n      } else {\n        arr[prop] = value;\n      }\n\n      return true;\n    }\n  });\n  return proxy;\n}\n\nfunction set(i, val, skipModified) {\n  const arr = this.__array;\n\n  if (skipModified) {\n    arr[i] = val;\n    return arr;\n  }\n\n  const value = DocumentArrayMethods._cast.call(this, val, i);\n\n  arr[i] = value;\n\n  DocumentArrayMethods._markModified.call(this, i);\n\n  return arr;\n}\n/*!\n * Module exports.\n */\n\n\nmodule.exports = MongooseDocumentArray;","map":{"version":3,"sources":["/home/gregorian/calendar-ui/node_modules/mongoose/lib/types/DocumentArray/index.js"],"names":["ArrayMethods","require","DocumentArrayMethods","Document","arrayAtomicsSymbol","arrayAtomicsBackupSymbol","arrayParentSymbol","arrayPathSymbol","arraySchemaSymbol","_basePush","Array","prototype","push","MongooseDocumentArray","values","path","doc","arr","internals","isArray","Object","assign","forEach","v","call","schema","$isMongooseArray","$isMongooseDocumentArray","casterConstructor","proxy","Proxy","get","target","prop","set","hasOwnProperty","value","test","i","val","skipModified","__array","_cast","_markModified","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayMethods = require('../array/methods');\nconst DocumentArrayMethods = require('./methods');\nconst Document = require('../../document');\n\nconst arrayAtomicsSymbol = require('../../helpers/symbols').arrayAtomicsSymbol;\nconst arrayAtomicsBackupSymbol = require('../../helpers/symbols').arrayAtomicsBackupSymbol;\nconst arrayParentSymbol = require('../../helpers/symbols').arrayParentSymbol;\nconst arrayPathSymbol = require('../../helpers/symbols').arrayPathSymbol;\nconst arraySchemaSymbol = require('../../helpers/symbols').arraySchemaSymbol;\n\nconst _basePush = Array.prototype.push;\n\n/**\n * DocumentArray constructor\n *\n * @param {Array} values\n * @param {String} path the path to this array\n * @param {Document} doc parent document\n * @api private\n * @return {MongooseDocumentArray}\n * @inherits MongooseArray\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseDocumentArray(values, path, doc) {\n  const arr = [];\n\n  const internals = {\n    [arrayAtomicsSymbol]: {},\n    [arrayAtomicsBackupSymbol]: void 0,\n    [arrayPathSymbol]: path,\n    [arraySchemaSymbol]: void 0,\n    [arrayParentSymbol]: void 0\n  };\n\n  if (Array.isArray(values)) {\n    if (values[arrayPathSymbol] === path &&\n        values[arrayParentSymbol] === doc) {\n      internals[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);\n    }\n    values.forEach(v => {\n      _basePush.call(arr, v);\n    });\n  }\n  internals[arrayPathSymbol] = path;\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020 && #3034)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc && doc instanceof Document) {\n    internals[arrayParentSymbol] = doc;\n    internals[arraySchemaSymbol] = doc.schema.path(path);\n\n    // `schema.path()` doesn't drill into nested arrays properly yet, see\n    // gh-6398, gh-6602. This is a workaround because nested arrays are\n    // always plain non-document arrays, so once you get to a document array\n    // nesting is done. Matryoshka code.\n    while (internals[arraySchemaSymbol] != null &&\n        internals[arraySchemaSymbol].$isMongooseArray &&\n        !internals[arraySchemaSymbol].$isMongooseDocumentArray) {\n      internals[arraySchemaSymbol] = internals[arraySchemaSymbol].casterConstructor;\n    }\n  }\n\n  const proxy = new Proxy(arr, {\n    get: function(target, prop) {\n      if (prop === 'isMongooseArray' ||\n          prop === 'isMongooseArrayProxy' ||\n          prop === 'isMongooseDocumentArray' ||\n          prop === 'isMongooseDocumentArrayProxy') {\n        return true;\n      }\n      if (prop === '__array') {\n        return arr;\n      }\n      if (prop === 'set') {\n        return set;\n      }\n      if (internals.hasOwnProperty(prop)) {\n        return internals[prop];\n      }\n      if (DocumentArrayMethods.hasOwnProperty(prop)) {\n        return DocumentArrayMethods[prop];\n      }\n      if (ArrayMethods.hasOwnProperty(prop)) {\n        return ArrayMethods[prop];\n      }\n\n      return arr[prop];\n    },\n    set: function(target, prop, value) {\n      if (typeof prop === 'string' && /^\\d+$/.test(prop)) {\n        set.call(proxy, prop, value);\n      } else if (internals.hasOwnProperty(prop)) {\n        internals[prop] = value;\n      } else {\n        arr[prop] = value;\n      }\n\n      return true;\n    }\n  });\n\n  return proxy;\n}\n\nfunction set(i, val, skipModified) {\n  const arr = this.__array;\n  if (skipModified) {\n    arr[i] = val;\n    return arr;\n  }\n  const value = DocumentArrayMethods._cast.call(this, val, i);\n  arr[i] = value;\n  DocumentArrayMethods._markModified.call(this, i);\n  return arr;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = MongooseDocumentArray;\n"]},"metadata":{},"sourceType":"script"}