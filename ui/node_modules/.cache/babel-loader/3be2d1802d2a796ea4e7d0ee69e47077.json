{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst Binary = require('../driver').get().Binary;\n\nconst Decimal128 = require('../types/decimal128');\n\nconst ObjectId = require('../types/objectid');\n\nconst isMongooseObject = require('./isMongooseObject');\n\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n/*!\n * ignore\n */\n\nfunction flatten(update, path, options, schema) {\n  let keys;\n\n  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({\n      transform: false,\n      virtuals: false\n    }));\n  } else {\n    keys = Object.keys(update || {});\n  }\n\n  const numKeys = keys.length;\n  const result = {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const val = update[key];\n    result[path + key] = val; // Avoid going into mixed paths if schema is specified\n\n    const keySchema = schema && schema.path && schema.path(path + key);\n    const isNested = schema && schema.nested && schema.nested[path + key];\n    if (keySchema && keySchema.instance === 'Mixed') continue;\n\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n\n      const flat = flatten(val, path + key, options, schema);\n\n      for (const k in flat) {\n        result[k] = flat[k];\n      }\n\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n\n    if (isNested) {\n      const paths = Object.keys(schema.paths);\n\n      for (const p of paths) {\n        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {\n          result[p] = void 0;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n/*!\n * ignore\n */\n\n\nfunction modifiedPaths(update, path, result) {\n  const keys = Object.keys(update || {});\n  const numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    let val = update[key];\n\n    const _path = path + key;\n\n    result[_path] = true;\n\n    if (_path.indexOf('.') !== -1) {\n      const sp = _path.split('.');\n\n      let cur = sp[0];\n\n      for (let i = 1; i < sp.length; ++i) {\n        result[cur] = true;\n        cur += '.' + sp[i];\n      }\n    }\n\n    if (isMongooseObject(val) && !Buffer.isBuffer(val)) {\n      val = val.toObject({\n        transform: false,\n        virtuals: false\n      });\n    }\n\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result);\n    }\n  }\n\n  return result;\n}\n/*!\n * ignore\n */\n\n\nfunction shouldFlatten(val) {\n  return val && typeof val === 'object' && !(val instanceof Date) && !(val instanceof ObjectId) && (!Array.isArray(val) || val.length > 0) && !(val instanceof Buffer) && !(val instanceof Decimal128) && !(val instanceof Binary);\n}","map":{"version":3,"sources":["/home/gregorian/calendar-ui/node_modules/mongoose/lib/helpers/common.js"],"names":["Binary","require","get","Decimal128","ObjectId","isMongooseObject","exports","flatten","modifiedPaths","update","path","options","schema","keys","Buffer","isBuffer","Object","toObject","transform","virtuals","numKeys","length","result","i","key","val","keySchema","isNested","nested","instance","shouldFlatten","skipArrays","Array","isArray","flat","k","paths","p","startsWith","hasOwnProperty","_path","indexOf","sp","split","cur","Date"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst Binary = require('../driver').get().Binary;\nconst Decimal128 = require('../types/decimal128');\nconst ObjectId = require('../types/objectid');\nconst isMongooseObject = require('./isMongooseObject');\n\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n\n/*!\n * ignore\n */\n\nfunction flatten(update, path, options, schema) {\n  let keys;\n  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({ transform: false, virtuals: false }));\n  } else {\n    keys = Object.keys(update || {});\n  }\n\n  const numKeys = keys.length;\n  const result = {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const val = update[key];\n    result[path + key] = val;\n\n    // Avoid going into mixed paths if schema is specified\n    const keySchema = schema && schema.path && schema.path(path + key);\n    const isNested = schema && schema.nested && schema.nested[path + key];\n    if (keySchema && keySchema.instance === 'Mixed') continue;\n\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n      const flat = flatten(val, path + key, options, schema);\n      for (const k in flat) {\n        result[k] = flat[k];\n      }\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n\n    if (isNested) {\n      const paths = Object.keys(schema.paths);\n      for (const p of paths) {\n        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {\n          result[p] = void 0;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction modifiedPaths(update, path, result) {\n  const keys = Object.keys(update || {});\n  const numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    let val = update[key];\n\n    const _path = path + key;\n    result[_path] = true;\n    if (_path.indexOf('.') !== -1) {\n      const sp = _path.split('.');\n      let cur = sp[0];\n      for (let i = 1; i < sp.length; ++i) {\n        result[cur] = true;\n        cur += '.' + sp[i];\n      }\n    }\n    if (isMongooseObject(val) && !Buffer.isBuffer(val)) {\n      val = val.toObject({ transform: false, virtuals: false });\n    }\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result);\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction shouldFlatten(val) {\n  return val &&\n    typeof val === 'object' &&\n    !(val instanceof Date) &&\n    !(val instanceof ObjectId) &&\n    (!Array.isArray(val) || val.length > 0) &&\n    !(val instanceof Buffer) &&\n    !(val instanceof Decimal128) &&\n    !(val instanceof Binary);\n}\n"]},"metadata":{},"sourceType":"script"}