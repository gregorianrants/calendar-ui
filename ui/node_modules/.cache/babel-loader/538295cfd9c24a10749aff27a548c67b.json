{"ast":null,"code":"'use strict';\n\nconst get = require('../get');\n\nconst getSchemaDiscriminatorByValue = require('../discriminator/getSchemaDiscriminatorByValue');\n/*!\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n */\n\n\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\n  options = options || {};\n  const typeOnly = options.typeOnly;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let schemaType = null;\n  let type = 'adhocOrUndefined';\n  const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.');\n    schemaType = schema.path(subpath);\n\n    if (schemaType == null) {\n      type = 'adhocOrUndefined';\n      continue;\n    }\n\n    if (schemaType.instance === 'Mixed') {\n      return typeOnly ? 'real' : schemaType;\n    }\n\n    type = schema.pathType(subpath);\n\n    if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) && schemaType.schema.discriminators != null) {\n      const discriminators = schemaType.schema.discriminators;\n      const discriminatorKey = doc.get(subpath + '.' + get(schemaType, 'schema.options.discriminatorKey'));\n\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n\n      const rest = parts.slice(i + 1).join('.');\n      return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);\n    }\n  } // Are we getting the whole schema or just the type, 'real', 'nested', etc.\n\n\n  return typeOnly ? type : schemaType;\n};","map":{"version":3,"sources":["/home/gregorian/calendar-ui/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js"],"names":["get","require","getSchemaDiscriminatorByValue","module","exports","getEmbeddedDiscriminatorPath","doc","path","options","typeOnly","parts","indexOf","split","schemaType","type","schema","discriminatorKey","i","length","subpath","slice","join","instance","pathType","$isSingleNested","$isMongooseDocumentArrayElement","discriminators","rest"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAMC,6BAA6B,GAAGD,OAAO,CAAC,gDAAD,CAA7C;AAEA;AACA;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB,SAASC,4BAAT,CAAsCC,GAAtC,EAA2CC,IAA3C,EAAiDC,OAAjD,EAA0D;AACzEA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,QAAMC,QAAQ,GAAGD,OAAO,CAACC,QAAzB;AACA,QAAMC,KAAK,GAAGH,IAAI,CAACI,OAAL,CAAa,GAAb,MAAsB,CAAC,CAAvB,GAA2B,CAACJ,IAAD,CAA3B,GAAoCA,IAAI,CAACK,KAAL,CAAW,GAAX,CAAlD;AACA,MAAIC,UAAU,GAAG,IAAjB;AACA,MAAIC,IAAI,GAAG,kBAAX;AAEA,QAAMC,MAAM,GAAGb,6BAA6B,CAACI,GAAG,CAACS,MAAL,EAAaT,GAAG,CAACN,GAAJ,CAAQM,GAAG,CAACS,MAAJ,CAAWP,OAAX,CAAmBQ,gBAA3B,CAAb,CAA7B,IAA2FV,GAAG,CAACS,MAA9G;;AAEA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,KAAK,CAACQ,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACrC,UAAME,OAAO,GAAGT,KAAK,CAACU,KAAN,CAAY,CAAZ,EAAeH,CAAC,GAAG,CAAnB,EAAsBI,IAAtB,CAA2B,GAA3B,CAAhB;AACAR,IAAAA,UAAU,GAAGE,MAAM,CAACR,IAAP,CAAYY,OAAZ,CAAb;;AACA,QAAIN,UAAU,IAAI,IAAlB,EAAwB;AACtBC,MAAAA,IAAI,GAAG,kBAAP;AACA;AACD;;AACD,QAAID,UAAU,CAACS,QAAX,KAAwB,OAA5B,EAAqC;AACnC,aAAOb,QAAQ,GAAG,MAAH,GAAYI,UAA3B;AACD;;AACDC,IAAAA,IAAI,GAAGC,MAAM,CAACQ,QAAP,CAAgBJ,OAAhB,CAAP;;AACA,QAAI,CAACN,UAAU,CAACW,eAAX,IAA8BX,UAAU,CAACY,+BAA1C,KACJZ,UAAU,CAACE,MAAX,CAAkBW,cAAlB,IAAoC,IADpC,EAC0C;AACxC,YAAMA,cAAc,GAAGb,UAAU,CAACE,MAAX,CAAkBW,cAAzC;AACA,YAAMV,gBAAgB,GAAGV,GAAG,CAACN,GAAJ,CAAQmB,OAAO,GAAG,GAAV,GAC/BnB,GAAG,CAACa,UAAD,EAAa,iCAAb,CADoB,CAAzB;;AAEA,UAAIG,gBAAgB,IAAI,IAApB,IAA4BU,cAAc,CAACV,gBAAD,CAAd,IAAoC,IAApE,EAA0E;AACxE;AACD;;AACD,YAAMW,IAAI,GAAGjB,KAAK,CAACU,KAAN,CAAYH,CAAC,GAAG,CAAhB,EAAmBI,IAAnB,CAAwB,GAAxB,CAAb;AACA,aAAOhB,4BAA4B,CAACC,GAAG,CAACN,GAAJ,CAAQmB,OAAR,CAAD,EAAmBQ,IAAnB,EAAyBnB,OAAzB,CAAnC;AACD;AACF,GA/BwE,CAiCzE;;;AACA,SAAOC,QAAQ,GAAGK,IAAH,GAAUD,UAAzB;AACD,CAnCD","sourcesContent":["'use strict';\n\nconst get = require('../get');\nconst getSchemaDiscriminatorByValue = require('../discriminator/getSchemaDiscriminatorByValue');\n\n/*!\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\n  options = options || {};\n  const typeOnly = options.typeOnly;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let schemaType = null;\n  let type = 'adhocOrUndefined';\n\n  const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.');\n    schemaType = schema.path(subpath);\n    if (schemaType == null) {\n      type = 'adhocOrUndefined';\n      continue;\n    }\n    if (schemaType.instance === 'Mixed') {\n      return typeOnly ? 'real' : schemaType;\n    }\n    type = schema.pathType(subpath);\n    if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) &&\n    schemaType.schema.discriminators != null) {\n      const discriminators = schemaType.schema.discriminators;\n      const discriminatorKey = doc.get(subpath + '.' +\n        get(schemaType, 'schema.options.discriminatorKey'));\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);\n    }\n  }\n\n  // Are we getting the whole schema or just the type, 'real', 'nested', etc.\n  return typeOnly ? type : schemaType;\n};\n"]},"metadata":{},"sourceType":"script"}